var data = {lines:[
{"lineNum":"    1","line":"pub use self::pipe::Awakener;"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"/// Default *nix awakener implementation"},
{"lineNum":"    4","line":"mod pipe {"},
{"lineNum":"    5","line":"    use {io, Evented, EventSet, PollOpt, Selector, Token, TryRead, TryWrite};"},
{"lineNum":"    6","line":"    use unix::{self, PipeReader, PipeWriter};"},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"    /*"},
{"lineNum":"    9","line":"     *"},
{"lineNum":"   10","line":"     * ===== Awakener ====="},
{"lineNum":"   11","line":"     *"},
{"lineNum":"   12","line":"     */"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"    pub struct Awakener {"},
{"lineNum":"   15","line":"        reader: PipeReader,"},
{"lineNum":"   16","line":"        writer: PipeWriter,"},
{"lineNum":"   17","line":"    }"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"    impl Awakener {"},
{"lineNum":"   20","line":"        pub fn new() -> io::Result<Awakener> {","class":"lineCov","hits":"1","order":"838","possible_hits":"1",},
{"lineNum":"   21","line":"            let (rd, wr) = try!(unix::pipe());","class":"linePartCov","hits":"1","order":"839","possible_hits":"2",},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"            Ok(Awakener {"},
{"lineNum":"   24","line":"                reader: rd,"},
{"lineNum":"   25","line":"                writer: wr,"},
{"lineNum":"   26","line":"            })"},
{"lineNum":"   27","line":"        }","class":"lineCov","hits":"1","order":"886","possible_hits":"1",},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"        pub fn wakeup(&self) -> io::Result<()> {"},
{"lineNum":"   30","line":"            (&self.writer).try_write(b\"0x01\").map(|_| ())"},
{"lineNum":"   31","line":"        }"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"        pub fn cleanup(&self) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   34","line":"            let mut buf = [0; 128];"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"            loop {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   37","line":"                // Consume data until all bytes are purged"},
{"lineNum":"   38","line":"                match (&self.reader).try_read(&mut buf) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   39","line":"                    Ok(Some(i)) if i > 0 => {},","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   40","line":"                    _ => return,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   41","line":"                }"},
{"lineNum":"   42","line":"            }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   43","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"        fn reader(&self) -> &PipeReader {","class":"lineCov","hits":"1","order":"930","possible_hits":"1",},
{"lineNum":"   46","line":"            &self.reader","class":"lineCov","hits":"1","order":"931","possible_hits":"1",},
{"lineNum":"   47","line":"        }","class":"linePartCov","hits":"1","order":"932","possible_hits":"2",},
{"lineNum":"   48","line":"    }"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"    impl Evented for Awakener {"},
{"lineNum":"   51","line":"        fn register(&self, selector: &mut Selector, token: Token, interest: EventSet, opts: PollOpt) -> io::Result<()> {","class":"lineCov","hits":"1","order":"928","possible_hits":"1",},
{"lineNum":"   52","line":"            self.reader().register(selector, token, interest, opts)","class":"lineCov","hits":"1","order":"929","possible_hits":"1",},
{"lineNum":"   53","line":"        }","class":"linePartCov","hits":"1","order":"1001","possible_hits":"2",},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"        fn reregister(&self, selector: &mut Selector, token: Token, interest: EventSet, opts: PollOpt) -> io::Result<()> {"},
{"lineNum":"   56","line":"            self.reader().reregister(selector, token, interest, opts)"},
{"lineNum":"   57","line":"        }"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"        fn deregister(&self, selector: &mut Selector) -> io::Result<()> {"},
{"lineNum":"   60","line":"            self.reader().deregister(selector)"},
{"lineNum":"   61","line":"        }"},
{"lineNum":"   62","line":"    }"},
{"lineNum":"   63","line":"}"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"/*"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"TODO: Bring back eventfd awakener."},
{"lineNum":"   68","line":"      Blocked on carllerche/nix-rust#98"},
{"lineNum":"   69","line":"mod eventfd {"},
{"lineNum":"   70","line":"    use {io, Io, TryRead, TryWrite};"},
{"lineNum":"   71","line":"    use std::mem;"},
{"lineNum":"   72","line":"    use std::os::unix::io::{RawFd, AsRawFd};"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"    const MARK: &\'static [u8] = b\"0x000x000x000x000x000x000x000x01\";"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"    mod nix {"},
{"lineNum":"   77","line":"        pub use nix::sys::eventfd::*;"},
{"lineNum":"   78","line":"    }"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"    pub struct Awakener {"},
{"lineNum":"   81","line":"        io: Io,"},
{"lineNum":"   82","line":"    }"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"    impl Awakener {"},
{"lineNum":"   85","line":"        pub fn new() -> io::Result<Awakener> {"},
{"lineNum":"   86","line":"            Ok(Awakener {"},
{"lineNum":"   87","line":"                io: Io::new(try!(eventfd())),"},
{"lineNum":"   88","line":"            })"},
{"lineNum":"   89","line":"        }"},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"        pub fn wakeup(&self) -> io::Result<()> {"},
{"lineNum":"   92","line":"            unsafe {"},
{"lineNum":"   93","line":"                let io: &mut Io = mem::transmute(&self.io);"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"                io.write_slice(MARK)"},
{"lineNum":"   96","line":"                    .map(|_| ())"},
{"lineNum":"   97","line":"            }"},
{"lineNum":"   98","line":"        }"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"        pub fn as_raw_fd(&self) -> Fd {"},
{"lineNum":"  101","line":"            self.io.as_raw_fd()"},
{"lineNum":"  102","line":"        }"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"        pub fn cleanup(&self) {"},
{"lineNum":"  105","line":"            let mut buf = [0; 8];"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"            loop {"},
{"lineNum":"  108","line":"                unsafe {"},
{"lineNum":"  109","line":"                    let io: &mut Io = mem::transmute(&self.io);"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"                    // Consume data until all bytes are purged"},
{"lineNum":"  112","line":"                    match io.read_slice(&mut buf) {"},
{"lineNum":"  113","line":"                        Ok(Some(i)) if i > 0 => {},"},
{"lineNum":"  114","line":"                        _ => return,"},
{"lineNum":"  115","line":"                    }"},
{"lineNum":"  116","line":"                }"},
{"lineNum":"  117","line":"            }"},
{"lineNum":"  118","line":"        }"},
{"lineNum":"  119","line":"    }"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"    fn eventfd() -> io::Result<Fd> {"},
{"lineNum":"  122","line":"        nix::eventfd(0, nix::EFD_CLOEXEC | nix::EFD_NONBLOCK)"},
{"lineNum":"  123","line":"            .map_err(super::from_nix_error)"},
{"lineNum":"  124","line":"    }"},
{"lineNum":"  125","line":"}"},
{"lineNum":"  126","line":" */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test_mio-b9fce113d2acf305", "date" : "2016-02-17 14:25:21", "instrumented" : 16, "covered" : 9,};
var merged_data = [];
