var data = {lines:[
{"lineNum":"    1","line":"// Copyright 2015 The Rust Project Developers. See the COPYRIGHT"},
{"lineNum":"    2","line":"// file at the top-level directory of this distribution and at"},
{"lineNum":"    3","line":"// http://rust-lang.org/COPYRIGHT."},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or"},
{"lineNum":"    6","line":"// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license"},
{"lineNum":"    7","line":"// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your"},
{"lineNum":"    8","line":"// option. This file may not be copied, modified, or distributed"},
{"lineNum":"    9","line":"// except according to those terms."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"use std::cell::RefCell;"},
{"lineNum":"   12","line":"use std::io;"},
{"lineNum":"   13","line":"use std::net::{ToSocketAddrs, TcpListener, TcpStream};"},
{"lineNum":"   14","line":"use std::fmt;"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"use IntoInner;"},
{"lineNum":"   17","line":"use socket::Socket;"},
{"lineNum":"   18","line":"use sys::c;"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"/// An \"in progress\" TCP socket which has not yet been connected or listened."},
{"lineNum":"   21","line":"///"},
{"lineNum":"   22","line":"/// Allows configuration of a socket before one of these operations is executed."},
{"lineNum":"   23","line":"pub struct TcpBuilder {"},
{"lineNum":"   24","line":"    socket: RefCell<Option<Socket>>,"},
{"lineNum":"   25","line":"}"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"impl TcpBuilder {"},
{"lineNum":"   28","line":"    /// Constructs a new TcpBuilder with the `AF_INET` domain, the `SOCK_STREAM`"},
{"lineNum":"   29","line":"    /// type, and with a protocol argument of 0."},
{"lineNum":"   30","line":"    ///"},
{"lineNum":"   31","line":"    /// Note that passing other kinds of flags or arguments can be done through"},
{"lineNum":"   32","line":"    /// the `FromRaw{Fd,Socket}` implementation."},
{"lineNum":"   33","line":"    pub fn new_v4() -> io::Result<TcpBuilder> {","class":"lineCov","hits":"1","order":"13","possible_hits":"1",},
{"lineNum":"   34","line":"        Socket::new(c::AF_INET, c::SOCK_STREAM).map(::FromInner::from_inner)","class":"lineCov","hits":"1","order":"14","possible_hits":"1",},
{"lineNum":"   35","line":"    }","class":"linePartCov","hits":"1","order":"44","possible_hits":"2",},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"    /// Constructs a new TcpBuilder with the `AF_INET6` domain, the `SOCK_STREAM`"},
{"lineNum":"   38","line":"    /// type, and with a protocol argument of 0."},
{"lineNum":"   39","line":"    ///"},
{"lineNum":"   40","line":"    /// Note that passing other kinds of flags or arguments can be done through"},
{"lineNum":"   41","line":"    /// the `FromRaw{Fd,Socket}` implementation."},
{"lineNum":"   42","line":"    pub fn new_v6() -> io::Result<TcpBuilder> {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   43","line":"        Socket::new(c::AF_INET6, c::SOCK_STREAM).map(::FromInner::from_inner)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   44","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"    /// Binds this socket to the specified address."},
{"lineNum":"   47","line":"    ///"},
{"lineNum":"   48","line":"    /// This function directly corresponds to the bind(2) function on Windows"},
{"lineNum":"   49","line":"    /// and Unix."},
{"lineNum":"   50","line":"    pub fn bind<T>(&self, addr: T) -> io::Result<&TcpBuilder>"},
{"lineNum":"   51","line":"        where T: ToSocketAddrs"},
{"lineNum":"   52","line":"    {","class":"linePartCov","hits":"2","order":"89","possible_hits":"3",},
{"lineNum":"   53","line":"        self.with_socket(|sock| {","class":"lineCov","hits":"3","order":"90","possible_hits":"3",},
{"lineNum":"   54","line":"            let addr = try!(::one_addr(addr));","class":"linePartCov","hits":"1","order":"94","possible_hits":"2",},
{"lineNum":"   55","line":"            sock.bind(&addr)","class":"lineCov","hits":"1","order":"122","possible_hits":"1",},
{"lineNum":"   56","line":"        }).map(|()| self)","class":"lineCov","hits":"2","order":"132","possible_hits":"2",},
{"lineNum":"   57","line":"    }"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"    /// Mark a socket as ready to accept incoming connection requests using"},
{"lineNum":"   60","line":"    /// accept()"},
{"lineNum":"   61","line":"    ///"},
{"lineNum":"   62","line":"    /// This function directly corresponds to the listen(2) function on Windows"},
{"lineNum":"   63","line":"    /// and Unix."},
{"lineNum":"   64","line":"    ///"},
{"lineNum":"   65","line":"    /// An error will be returned if `listen` or `connect` has already been"},
{"lineNum":"   66","line":"    /// called on this builder."},
{"lineNum":"   67","line":"    pub fn listen(&self, backlog: i32) -> io::Result<TcpListener> {","class":"lineCov","hits":"1","order":"134","possible_hits":"1",},
{"lineNum":"   68","line":"        self.with_socket(|sock| {","class":"lineCov","hits":"2","order":"135","possible_hits":"2",},
{"lineNum":"   69","line":"            sock.listen(backlog)","class":"lineCov","hits":"1","order":"136","possible_hits":"1",},
{"lineNum":"   70","line":"        }).and_then(|()| {","class":"linePartCov","hits":"2","order":"140","possible_hits":"3",},
{"lineNum":"   71","line":"            self.to_tcp_listener()","class":"lineCov","hits":"1","order":"144","possible_hits":"1",},
{"lineNum":"   72","line":"        })","class":"linePartCov","hits":"1","order":"187","possible_hits":"2",},
{"lineNum":"   73","line":"    }","class":"linePartCov","hits":"1","order":"188","possible_hits":"2",},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"    /// Initiate a connection on this socket to the specified address."},
{"lineNum":"   76","line":"    ///"},
{"lineNum":"   77","line":"    /// This function directly corresponds to the connect(2) function on Windows"},
{"lineNum":"   78","line":"    /// and Unix."},
{"lineNum":"   79","line":"    ///"},
{"lineNum":"   80","line":"    /// An error will be returned if `listen` or `connect` has already been"},
{"lineNum":"   81","line":"    /// called on this builder."},
{"lineNum":"   82","line":"    pub fn connect<T>(&self, addr: T) -> io::Result<TcpStream>"},
{"lineNum":"   83","line":"        where T: ToSocketAddrs"},
{"lineNum":"   84","line":"    {"},
{"lineNum":"   85","line":"        self.with_socket(|sock| {"},
{"lineNum":"   86","line":"            let err = io::Error::new(io::ErrorKind::Other,"},
{"lineNum":"   87","line":"                                     \"no socket addresses resolved\");"},
{"lineNum":"   88","line":"            try!(addr.to_socket_addrs()).fold(Err(err), |prev, addr| {"},
{"lineNum":"   89","line":"                prev.or_else(|_| sock.connect(&addr))"},
{"lineNum":"   90","line":"            })"},
{"lineNum":"   91","line":"        }).and_then(|()| {"},
{"lineNum":"   92","line":"            self.to_tcp_stream()"},
{"lineNum":"   93","line":"        })"},
{"lineNum":"   94","line":"    }"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"    /// Converts this builder into a `TcpStream`"},
{"lineNum":"   97","line":"    ///"},
{"lineNum":"   98","line":"    /// This function will consume the internal socket and return it re-wrapped"},
{"lineNum":"   99","line":"    /// as a `TcpStream`. An error will be returned if the internal socket has"},
{"lineNum":"  100","line":"    /// already been consumed from a successful call to `connect`, `listen`,"},
{"lineNum":"  101","line":"    /// etc."},
{"lineNum":"  102","line":"    pub fn to_tcp_stream(&self) -> io::Result<TcpStream> {"},
{"lineNum":"  103","line":"        self.socket.borrow_mut().take().map(|s| s.into_inner().into_tcp_stream())"},
{"lineNum":"  104","line":"            .ok_or(io::Error::new(io::ErrorKind::Other,"},
{"lineNum":"  105","line":"                                  \"socket has already been consumed\"))"},
{"lineNum":"  106","line":"    }"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"    /// Converts this builder into a `TcpListener`"},
{"lineNum":"  109","line":"    ///"},
{"lineNum":"  110","line":"    /// This function will consume the internal socket and return it re-wrapped"},
{"lineNum":"  111","line":"    /// as a `TcpListener`. An error will be returned if the internal socket has"},
{"lineNum":"  112","line":"    /// already been consumed from a successful call to `connect`, `listen`,"},
{"lineNum":"  113","line":"    /// etc."},
{"lineNum":"  114","line":"    pub fn to_tcp_listener(&self) -> io::Result<TcpListener> {","class":"lineCov","hits":"1","order":"145","possible_hits":"1",},
{"lineNum":"  115","line":"        self.socket.borrow_mut().take()","class":"lineCov","hits":"3","order":"146","possible_hits":"3",},
{"lineNum":"  116","line":"            .map(|s| s.into_inner().into_tcp_listener())","class":"lineCov","hits":"2","order":"160","possible_hits":"2",},
{"lineNum":"  117","line":"            .ok_or(io::Error::new(io::ErrorKind::Other,","class":"lineCov","hits":"1","order":"172","possible_hits":"1",},
{"lineNum":"  118","line":"                                  \"socket has already been consumed\"))"},
{"lineNum":"  119","line":"    }","class":"linePartCov","hits":"1","order":"183","possible_hits":"2",},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"    fn with_socket<F>(&self, f: F) -> io::Result<()>"},
{"lineNum":"  122","line":"        where F: FnOnce(&Socket) -> io::Result<()>"},
{"lineNum":"  123","line":"    {","class":"linePartCov","hits":"3","order":"91","possible_hits":"4",},
{"lineNum":"  124","line":"        match *self.socket.borrow() {","class":"lineCov","hits":"2","order":"92","possible_hits":"2",},
{"lineNum":"  125","line":"            Some(ref s) => f(s),","class":"lineCov","hits":"2","order":"93","possible_hits":"2",},
{"lineNum":"  126","line":"            None => Err(io::Error::new(io::ErrorKind::Other,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  127","line":"                                       \"builder has already finished its socket\")),"},
{"lineNum":"  128","line":"        }"},
{"lineNum":"  129","line":"    }","class":"linePartCov","hits":"1","order":"141","possible_hits":"2",},
{"lineNum":"  130","line":"}"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"impl fmt::Debug for TcpBuilder {"},
{"lineNum":"  133","line":"    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  134","line":"        write!(f, \"TcpBuilder {{ socket: {:?} }}\","},
{"lineNum":"  135","line":"               self.socket.borrow().as_ref().unwrap())"},
{"lineNum":"  136","line":"    }"},
{"lineNum":"  137","line":"}"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"impl ::AsInner for TcpBuilder {"},
{"lineNum":"  140","line":"    type Inner = RefCell<Option<Socket>>;"},
{"lineNum":"  141","line":"    fn as_inner(&self) -> &RefCell<Option<Socket>> { &self.socket }","class":"lineCov","hits":"2","order":"51","possible_hits":"2",},
{"lineNum":"  142","line":"}"},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"impl ::FromInner for TcpBuilder {"},
{"lineNum":"  145","line":"    type Inner = Socket;"},
{"lineNum":"  146","line":"    fn from_inner(sock: Socket) -> TcpBuilder {","class":"lineCov","hits":"1","order":"36","possible_hits":"1",},
{"lineNum":"  147","line":"        TcpBuilder { socket: RefCell::new(Some(sock)) }","class":"lineCov","hits":"1","order":"37","possible_hits":"1",},
{"lineNum":"  148","line":"    }","class":"linePartCov","hits":"1","order":"42","possible_hits":"2",},
{"lineNum":"  149","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test_mio-b9fce113d2acf305", "date" : "2016-02-17 13:22:44", "instrumented" : 32, "covered" : 28,};
var merged_data = [];
