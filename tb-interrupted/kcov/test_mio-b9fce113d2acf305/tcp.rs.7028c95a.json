var data = {lines:[
{"lineNum":"    1","line":"use std::io::{Read, Write};"},
{"lineNum":"    2","line":"use std::net::{self, SocketAddr, SocketAddrV4, SocketAddrV6, Ipv4Addr, Ipv6Addr};","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"use net2::TcpBuilder;"},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"use {io, sys, Evented, EventSet, PollOpt, Selector, Token, TryAccept};"},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"/*"},
{"lineNum":"    9","line":" *"},
{"lineNum":"   10","line":" * ===== TcpStream ====="},
{"lineNum":"   11","line":" *"},
{"lineNum":"   12","line":" */"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#[derive(Debug)]"},
{"lineNum":"   15","line":"pub struct TcpStream {"},
{"lineNum":"   16","line":"    sys: sys::TcpStream,"},
{"lineNum":"   17","line":"}"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"pub use std::net::Shutdown;"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"impl TcpStream {"},
{"lineNum":"   22","line":"    /// Create a new TCP stream an issue a non-blocking connect to the specified"},
{"lineNum":"   23","line":"    /// address."},
{"lineNum":"   24","line":"    ///"},
{"lineNum":"   25","line":"    /// This convenience method is available and uses the system\'s default"},
{"lineNum":"   26","line":"    /// options when creating a socket which is then conntected. If fine-grained"},
{"lineNum":"   27","line":"    /// control over the creation of the socket is desired, you can use"},
{"lineNum":"   28","line":"    /// `net2::TcpBuilder` to configure a socket and then pass its socket to"},
{"lineNum":"   29","line":"    /// `TcpStream::connect_stream` to transfer ownership into mio and schedule"},
{"lineNum":"   30","line":"    /// the connect operation."},
{"lineNum":"   31","line":"    pub fn connect(addr: &SocketAddr) -> io::Result<TcpStream> {"},
{"lineNum":"   32","line":"        let sock = try!(match *addr {"},
{"lineNum":"   33","line":"            SocketAddr::V4(..) => TcpBuilder::new_v4(),"},
{"lineNum":"   34","line":"            SocketAddr::V6(..) => TcpBuilder::new_v6(),"},
{"lineNum":"   35","line":"        });"},
{"lineNum":"   36","line":"        // Required on Windows for a future `connect_overlapped` operation to be"},
{"lineNum":"   37","line":"        // executed successfully."},
{"lineNum":"   38","line":"        if cfg!(windows) {"},
{"lineNum":"   39","line":"            try!(sock.bind(&inaddr_any(addr)));"},
{"lineNum":"   40","line":"        }"},
{"lineNum":"   41","line":"        TcpStream::connect_stream(try!(sock.to_tcp_stream()), addr)"},
{"lineNum":"   42","line":"    }"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"    /// Creates a new `TcpStream` from the pending socket inside the given"},
{"lineNum":"   45","line":"    /// `std::net::TcpBuilder`, connecting it to the address specified."},
{"lineNum":"   46","line":"    ///"},
{"lineNum":"   47","line":"    /// This constructor allows configuring the socket before it\'s actually"},
{"lineNum":"   48","line":"    /// connected, and this function will transfer ownership to the returned"},
{"lineNum":"   49","line":"    /// `TcpStream` if successful. An unconnected `TcpStream` can be created"},
{"lineNum":"   50","line":"    /// with the `net2::TcpBuilder` type (and also configured via that route)."},
{"lineNum":"   51","line":"    ///"},
{"lineNum":"   52","line":"    /// The platform specific behavior of this function looks like:"},
{"lineNum":"   53","line":"    ///"},
{"lineNum":"   54","line":"    /// * On Unix, the socket is placed into nonblocking mode and then a"},
{"lineNum":"   55","line":"    ///   `connect` call is issued."},
{"lineNum":"   56","line":"    ///"},
{"lineNum":"   57","line":"    /// * On Windows, the address is stored internally and the connect operation"},
{"lineNum":"   58","line":"    ///   is issued when the returned `TcpStream` is registered with an event"},
{"lineNum":"   59","line":"    ///   loop. Note that on Windows you must `bind` a socket before it can be"},
{"lineNum":"   60","line":"    ///   connected, so if a custom `TcpBuilder` is used it should be bound"},
{"lineNum":"   61","line":"    ///   (perhaps to `INADDR_ANY`) before this method is called."},
{"lineNum":"   62","line":"    pub fn connect_stream(stream: net::TcpStream,"},
{"lineNum":"   63","line":"                          addr: &SocketAddr) -> io::Result<TcpStream> {"},
{"lineNum":"   64","line":"        Ok(TcpStream {"},
{"lineNum":"   65","line":"            sys: try!(sys::TcpStream::connect(stream, addr)),"},
{"lineNum":"   66","line":"        })"},
{"lineNum":"   67","line":"    }"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"    pub fn peer_addr(&self) -> io::Result<SocketAddr> {"},
{"lineNum":"   70","line":"        self.sys.peer_addr()"},
{"lineNum":"   71","line":"    }"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"    pub fn local_addr(&self) -> io::Result<SocketAddr> {"},
{"lineNum":"   74","line":"        self.sys.local_addr()"},
{"lineNum":"   75","line":"    }"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"    pub fn try_clone(&self) -> io::Result<TcpStream> {"},
{"lineNum":"   78","line":"        self.sys.try_clone().map(|s| TcpStream { sys: s })"},
{"lineNum":"   79","line":"    }"},
{"lineNum":"   80","line":"    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {"},
{"lineNum":"   81","line":"        self.sys.shutdown(how)"},
{"lineNum":"   82","line":"    }"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {"},
{"lineNum":"   85","line":"        self.sys.set_nodelay(nodelay)"},
{"lineNum":"   86","line":"    }"},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"    pub fn set_keepalive(&self, seconds: Option<u32>) -> io::Result<()> {"},
{"lineNum":"   89","line":"        self.sys.set_keepalive(seconds)"},
{"lineNum":"   90","line":"    }"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"    pub fn take_socket_error(&self) -> io::Result<()> {"},
{"lineNum":"   93","line":"        self.sys.take_socket_error()"},
{"lineNum":"   94","line":"    }"},
{"lineNum":"   95","line":"}"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"fn inaddr_any(other: &SocketAddr) -> SocketAddr {"},
{"lineNum":"   98","line":"    match *other {"},
{"lineNum":"   99","line":"        SocketAddr::V4(..) => {"},
{"lineNum":"  100","line":"            let any = Ipv4Addr::new(0, 0, 0, 0);"},
{"lineNum":"  101","line":"            let addr = SocketAddrV4::new(any, 0);"},
{"lineNum":"  102","line":"            SocketAddr::V4(addr)"},
{"lineNum":"  103","line":"        }"},
{"lineNum":"  104","line":"        SocketAddr::V6(..) => {"},
{"lineNum":"  105","line":"            let any = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0);"},
{"lineNum":"  106","line":"            let addr = SocketAddrV6::new(any, 0, 0, 0);"},
{"lineNum":"  107","line":"            SocketAddr::V6(addr)"},
{"lineNum":"  108","line":"        }"},
{"lineNum":"  109","line":"    }"},
{"lineNum":"  110","line":"}"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"impl Read for TcpStream {"},
{"lineNum":"  113","line":"    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {"},
{"lineNum":"  114","line":"        self.sys.read(buf)"},
{"lineNum":"  115","line":"    }"},
{"lineNum":"  116","line":"}"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"impl Write for TcpStream {"},
{"lineNum":"  119","line":"    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {"},
{"lineNum":"  120","line":"        self.sys.write(buf)"},
{"lineNum":"  121","line":"    }"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"    fn flush(&mut self) -> io::Result<()> {"},
{"lineNum":"  124","line":"        self.sys.flush()"},
{"lineNum":"  125","line":"    }"},
{"lineNum":"  126","line":"}"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"impl Evented for TcpStream {"},
{"lineNum":"  129","line":"    fn register(&self, selector: &mut Selector, token: Token,"},
{"lineNum":"  130","line":"                interest: EventSet, opts: PollOpt) -> io::Result<()> {","class":"lineCov","hits":"1","order":"1399","possible_hits":"1",},
{"lineNum":"  131","line":"        self.sys.register(selector, token, interest, opts)","class":"lineCov","hits":"1","order":"1400","possible_hits":"1",},
{"lineNum":"  132","line":"    }","class":"linePartCov","hits":"1","order":"1411","possible_hits":"2",},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"    fn reregister(&self, selector: &mut Selector, token: Token,"},
{"lineNum":"  135","line":"                  interest: EventSet, opts: PollOpt) -> io::Result<()> {","class":"lineCov","hits":"1","order":"1741","possible_hits":"1",},
{"lineNum":"  136","line":"        self.sys.reregister(selector, token, interest, opts)","class":"lineCov","hits":"1","order":"1742","possible_hits":"1",},
{"lineNum":"  137","line":"    }","class":"linePartCov","hits":"1","order":"1754","possible_hits":"2",},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"    fn deregister(&self, selector: &mut Selector) -> io::Result<()> {"},
{"lineNum":"  140","line":"        self.sys.deregister(selector)"},
{"lineNum":"  141","line":"    }"},
{"lineNum":"  142","line":"}"},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"/*"},
{"lineNum":"  145","line":" *"},
{"lineNum":"  146","line":" * ===== TcpListener ====="},
{"lineNum":"  147","line":" *"},
{"lineNum":"  148","line":" */"},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"#[derive(Debug)]"},
{"lineNum":"  151","line":"pub struct TcpListener {"},
{"lineNum":"  152","line":"    sys: sys::TcpListener,"},
{"lineNum":"  153","line":"}"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"impl TcpListener {"},
{"lineNum":"  156","line":"    /// Convenience method to bind a new TCP listener to the specified address"},
{"lineNum":"  157","line":"    /// to receive new connections."},
{"lineNum":"  158","line":"    ///"},
{"lineNum":"  159","line":"    /// This function will take the following steps:"},
{"lineNum":"  160","line":"    ///"},
{"lineNum":"  161","line":"    /// 1. Create a new TCP socket."},
{"lineNum":"  162","line":"    /// 2. Set the `SO_REUSEADDR` option on the socket."},
{"lineNum":"  163","line":"    /// 3. Bind the socket to the specified address."},
{"lineNum":"  164","line":"    /// 4. Call `listen` on the socket to prepare it to receive new connections."},
{"lineNum":"  165","line":"    ///"},
{"lineNum":"  166","line":"    /// If fine-grained control over the binding and listening process for a"},
{"lineNum":"  167","line":"    /// socket is desired then the `net2::TcpBuilder` methods can be used in"},
{"lineNum":"  168","line":"    /// combination with the `TcpListener::from_listener` method to transfer"},
{"lineNum":"  169","line":"    /// ownership into mio."},
{"lineNum":"  170","line":"    pub fn bind(addr: &SocketAddr) -> io::Result<TcpListener> {","class":"lineCov","hits":"1","order":"10","possible_hits":"1",},
{"lineNum":"  171","line":"        // Create the socket"},
{"lineNum":"  172","line":"        let sock = try!(match *addr {","class":"linePartCov","hits":"2","order":"11","possible_hits":"3",},
{"lineNum":"  173","line":"            SocketAddr::V4(..) => TcpBuilder::new_v4(),","class":"lineCov","hits":"1","order":"12","possible_hits":"1",},
{"lineNum":"  174","line":"            SocketAddr::V6(..) => TcpBuilder::new_v6(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  175","line":"        });"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"        // Set SO_REUSEADDR"},
{"lineNum":"  178","line":"        try!(sock.reuse_address(true));","class":"lineCov","hits":"1","order":"45","possible_hits":"1",},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"        // Bind the socket"},
{"lineNum":"  181","line":"        try!(sock.bind(addr));","class":"lineCov","hits":"1","order":"88","possible_hits":"1",},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"        // listen"},
{"lineNum":"  184","line":"        let listener = try!(sock.listen(1024));","class":"linePartCov","hits":"1","order":"133","possible_hits":"2",},
{"lineNum":"  185","line":"        Ok(TcpListener {","class":"lineCov","hits":"1","order":"189","possible_hits":"1",},
{"lineNum":"  186","line":"            sys: try!(sys::TcpListener::new(listener, addr)),","class":"linePartCov","hits":"2","order":"190","possible_hits":"4",},
{"lineNum":"  187","line":"        })"},
{"lineNum":"  188","line":"    }","class":"linePartCov","hits":"1","order":"206","possible_hits":"6",},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"    /// Creates a new `TcpListener` from an instance of a"},
{"lineNum":"  191","line":"    /// `std::net::TcpListener` type."},
{"lineNum":"  192","line":"    ///"},
{"lineNum":"  193","line":"    /// This function will set the `listener` provided into nonblocking mode on"},
{"lineNum":"  194","line":"    /// Unix, and otherwise the stream will just be wrapped up in an mio stream"},
{"lineNum":"  195","line":"    /// ready to accept new connections and become associated with an event"},
{"lineNum":"  196","line":"    /// loop."},
{"lineNum":"  197","line":"    ///"},
{"lineNum":"  198","line":"    /// The address provided must be the address that the listener is bound to."},
{"lineNum":"  199","line":"    pub fn from_listener(listener: net::TcpListener, addr: &SocketAddr)"},
{"lineNum":"  200","line":"                         -> io::Result<TcpListener> {"},
{"lineNum":"  201","line":"        sys::TcpListener::new(listener, addr).map(|s| TcpListener { sys: s })"},
{"lineNum":"  202","line":"    }"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"    /// Accepts a new `TcpStream`."},
{"lineNum":"  205","line":"    ///"},
{"lineNum":"  206","line":"    /// Returns a `Ok(None)` when the socket `WOULDBLOCK`, this means the stream"},
{"lineNum":"  207","line":"    /// will be ready at a later point. If an accepted stream is returned, the"},
{"lineNum":"  208","line":"    /// address of the peer is returned along with it"},
{"lineNum":"  209","line":"    pub fn accept(&self) -> io::Result<Option<(TcpStream, SocketAddr)>> {","class":"lineCov","hits":"1","order":"1345","possible_hits":"1",},
{"lineNum":"  210","line":"        self.sys.accept().map(|o| o.map(|(s, a)| (TcpStream { sys: s }, a)))","class":"linePartCov","hits":"5","order":"1346","possible_hits":"6",},
{"lineNum":"  211","line":"    }","class":"linePartCov","hits":"1","order":"1356","possible_hits":"2",},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"    pub fn local_addr(&self) -> io::Result<SocketAddr> {","class":"lineCov","hits":"1","order":"208","possible_hits":"1",},
{"lineNum":"  214","line":"        self.sys.local_addr()","class":"lineCov","hits":"1","order":"209","possible_hits":"1",},
{"lineNum":"  215","line":"    }","class":"linePartCov","hits":"1","order":"213","possible_hits":"2",},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"    pub fn try_clone(&self) -> io::Result<TcpListener> {"},
{"lineNum":"  218","line":"        self.sys.try_clone().map(|s| TcpListener { sys: s })"},
{"lineNum":"  219","line":"    }"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"    pub fn take_socket_error(&self) -> io::Result<()> {"},
{"lineNum":"  222","line":"        self.sys.take_socket_error()"},
{"lineNum":"  223","line":"    }"},
{"lineNum":"  224","line":"}"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"impl Evented for TcpListener {"},
{"lineNum":"  227","line":"    fn register(&self, selector: &mut Selector, token: Token,"},
{"lineNum":"  228","line":"                interest: EventSet, opts: PollOpt) -> io::Result<()> {","class":"lineCov","hits":"1","order":"1160","possible_hits":"1",},
{"lineNum":"  229","line":"        self.sys.register(selector, token, interest, opts)","class":"lineCov","hits":"1","order":"1161","possible_hits":"1",},
{"lineNum":"  230","line":"    }","class":"linePartCov","hits":"1","order":"1180","possible_hits":"2",},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"    fn reregister(&self, selector: &mut Selector, token: Token,"},
{"lineNum":"  233","line":"                  interest: EventSet, opts: PollOpt) -> io::Result<()> {"},
{"lineNum":"  234","line":"        self.sys.reregister(selector, token, interest, opts)"},
{"lineNum":"  235","line":"    }"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"    fn deregister(&self, selector: &mut Selector) -> io::Result<()> {"},
{"lineNum":"  238","line":"        self.sys.deregister(selector)"},
{"lineNum":"  239","line":"    }"},
{"lineNum":"  240","line":"}"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"impl TryAccept for TcpListener {"},
{"lineNum":"  243","line":"    type Output = TcpStream;"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"    fn accept(&self) -> io::Result<Option<TcpStream>> {"},
{"lineNum":"  246","line":"        TcpListener::accept(self).map(|a| a.map(|(s, _)| s))"},
{"lineNum":"  247","line":"    }"},
{"lineNum":"  248","line":"}"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"/*"},
{"lineNum":"  251","line":" *"},
{"lineNum":"  252","line":" * ===== UNIX ext ====="},
{"lineNum":"  253","line":" *"},
{"lineNum":"  254","line":" */"},
{"lineNum":"  255","line":""},
{"lineNum":"  256","line":"#[cfg(unix)]"},
{"lineNum":"  257","line":"use std::os::unix::io::{AsRawFd, FromRawFd, RawFd};"},
{"lineNum":"  258","line":""},
{"lineNum":"  259","line":"#[cfg(unix)]"},
{"lineNum":"  260","line":"impl AsRawFd for TcpStream {"},
{"lineNum":"  261","line":"    fn as_raw_fd(&self) -> RawFd {","class":"lineCov","hits":"1","order":"1359","possible_hits":"1",},
{"lineNum":"  262","line":"        self.sys.as_raw_fd()","class":"lineCov","hits":"1","order":"1360","possible_hits":"1",},
{"lineNum":"  263","line":"    }","class":"linePartCov","hits":"1","order":"1364","possible_hits":"2",},
{"lineNum":"  264","line":"}"},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"#[cfg(unix)]"},
{"lineNum":"  267","line":"impl FromRawFd for TcpStream {"},
{"lineNum":"  268","line":"    unsafe fn from_raw_fd(fd: RawFd) -> TcpStream {"},
{"lineNum":"  269","line":"        TcpStream { sys: FromRawFd::from_raw_fd(fd) }"},
{"lineNum":"  270","line":"    }"},
{"lineNum":"  271","line":"}"},
{"lineNum":"  272","line":""},
{"lineNum":"  273","line":"#[cfg(unix)]"},
{"lineNum":"  274","line":"impl AsRawFd for TcpListener {"},
{"lineNum":"  275","line":"    fn as_raw_fd(&self) -> RawFd {"},
{"lineNum":"  276","line":"        self.sys.as_raw_fd()"},
{"lineNum":"  277","line":"    }"},
{"lineNum":"  278","line":"}"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"#[cfg(unix)]"},
{"lineNum":"  281","line":"impl FromRawFd for TcpListener {"},
{"lineNum":"  282","line":"    unsafe fn from_raw_fd(fd: RawFd) -> TcpListener {"},
{"lineNum":"  283","line":"        TcpListener { sys: FromRawFd::from_raw_fd(fd) }"},
{"lineNum":"  284","line":"    }"},
{"lineNum":"  285","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test_mio-b9fce113d2acf305", "date" : "2016-02-17 13:22:44", "instrumented" : 29, "covered" : 27,};
var merged_data = [];
