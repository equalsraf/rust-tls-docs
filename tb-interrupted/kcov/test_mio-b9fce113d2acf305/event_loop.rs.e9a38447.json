var data = {lines:[
{"lineNum":"    1","line":"use {Handler, Evented, Poll, NotifyError, Token};"},
{"lineNum":"    2","line":"use event::{IoEvent, EventSet, PollOpt};","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"    3","line":"use notify::Notify;"},
{"lineNum":"    4","line":"use timer::{Timer, Timeout, TimerResult};"},
{"lineNum":"    5","line":"use std::{cmp, io, fmt, thread, usize};"},
{"lineNum":"    6","line":"use std::default::Default;"},
{"lineNum":"    7","line":"","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"    8","line":"/// Configure EventLoop runtime details"},
{"lineNum":"    9","line":"#[derive(Clone, Debug)]"},
{"lineNum":"   10","line":"pub struct EventLoopConfig {"},
{"lineNum":"   11","line":"    // == Notifications =="},
{"lineNum":"   12","line":"    notify_capacity: usize,"},
{"lineNum":"   13","line":"    messages_per_tick: usize,"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"    // == Timer =="},
{"lineNum":"   16","line":"    timer_tick_ms: u64,"},
{"lineNum":"   17","line":"    timer_wheel_size: usize,"},
{"lineNum":"   18","line":"    timer_capacity: usize,"},
{"lineNum":"   19","line":"}"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"impl EventLoopConfig {"},
{"lineNum":"   22","line":"    /// Creates a new configuration for the event loop with all default options"},
{"lineNum":"   23","line":"    /// specified."},
{"lineNum":"   24","line":"    pub fn new() -> EventLoopConfig {","class":"lineCov","hits":"1","order":"634","possible_hits":"1",},
{"lineNum":"   25","line":"        EventLoopConfig {"},
{"lineNum":"   26","line":"            notify_capacity: 4_096,"},
{"lineNum":"   27","line":"            messages_per_tick: 256,"},
{"lineNum":"   28","line":"            timer_tick_ms: 100,"},
{"lineNum":"   29","line":"            timer_wheel_size: 1_024,"},
{"lineNum":"   30","line":"            timer_capacity: 65_536,"},
{"lineNum":"   31","line":"        }"},
{"lineNum":"   32","line":"    }","class":"linePartCov","hits":"1","order":"635","possible_hits":"2",},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"    /// Sets the maximum number of messages that can be buffered on the event"},
{"lineNum":"   35","line":"    /// loop\'s notification channel before a send will fail."},
{"lineNum":"   36","line":"    ///"},
{"lineNum":"   37","line":"    /// The default value for this is 4096."},
{"lineNum":"   38","line":"    pub fn notify_capacity(&mut self, capacity: usize) -> &mut Self {"},
{"lineNum":"   39","line":"        self.notify_capacity = capacity;"},
{"lineNum":"   40","line":"        self"},
{"lineNum":"   41","line":"    }"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"    /// Sets the maximum number of messages that can be processed on any tick of"},
{"lineNum":"   44","line":"    /// the event loop."},
{"lineNum":"   45","line":"    ///"},
{"lineNum":"   46","line":"    /// The default value for this is 256."},
{"lineNum":"   47","line":"    pub fn messages_per_tick(&mut self, messages: usize) -> &mut Self {"},
{"lineNum":"   48","line":"        self.messages_per_tick = messages;"},
{"lineNum":"   49","line":"        self"},
{"lineNum":"   50","line":"    }"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"    pub fn timer_tick_ms(&mut self, ms: u64) -> &mut Self {"},
{"lineNum":"   53","line":"        self.timer_tick_ms = ms;"},
{"lineNum":"   54","line":"        self"},
{"lineNum":"   55","line":"    }"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"    pub fn timer_wheel_size(&mut self, size: usize) -> &mut Self {"},
{"lineNum":"   58","line":"        self.timer_wheel_size = size;"},
{"lineNum":"   59","line":"        self"},
{"lineNum":"   60","line":"    }"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"    pub fn timer_capacity(&mut self, cap: usize) -> &mut Self {"},
{"lineNum":"   63","line":"        self.timer_capacity = cap;"},
{"lineNum":"   64","line":"        self"},
{"lineNum":"   65","line":"    }"},
{"lineNum":"   66","line":"}"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"impl Default for EventLoopConfig {"},
{"lineNum":"   69","line":"    fn default() -> EventLoopConfig {"},
{"lineNum":"   70","line":"        EventLoopConfig::new()"},
{"lineNum":"   71","line":"    }"},
{"lineNum":"   72","line":"}"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"/// Single threaded IO event loop."},
{"lineNum":"   75","line":"#[derive(Debug)]"},
{"lineNum":"   76","line":"pub struct EventLoop<H: Handler> {"},
{"lineNum":"   77","line":"    run: bool,"},
{"lineNum":"   78","line":"    poll: Poll,"},
{"lineNum":"   79","line":"    timer: Timer<H::Timeout>,"},
{"lineNum":"   80","line":"    notify: Notify<H::Message>,"},
{"lineNum":"   81","line":"    config: EventLoopConfig,"},
{"lineNum":"   82","line":"}"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"// Token used to represent notifications"},
{"lineNum":"   85","line":"const NOTIFY: Token = Token(usize::MAX);"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"impl<H: Handler> EventLoop<H> {"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"    /// Initializes a new event loop using default configuration settings. The"},
{"lineNum":"   90","line":"    /// event loop will not be running yet."},
{"lineNum":"   91","line":"    pub fn new() -> io::Result<EventLoop<H>> {","class":"linePartCov","hits":"2","order":"632","possible_hits":"3",},
{"lineNum":"   92","line":"        EventLoop::configured(EventLoopConfig::new())","class":"lineCov","hits":"1","order":"633","possible_hits":"1",},
{"lineNum":"   93","line":"    }"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"    pub fn configured(config: EventLoopConfig) -> io::Result<EventLoop<H>> {","class":"linePartCov","hits":"2","order":"636","possible_hits":"7",},
{"lineNum":"   96","line":"        // Create the IO poller"},
{"lineNum":"   97","line":"        let mut poll = try!(Poll::new());","class":"linePartCov","hits":"2","order":"637","possible_hits":"3",},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"        // Create the timer"},
{"lineNum":"  100","line":"        let mut timer = Timer::new(","class":"lineCov","hits":"1","order":"683","possible_hits":"1",},
{"lineNum":"  101","line":"            config.timer_tick_ms,","class":"lineCov","hits":"1","order":"680","possible_hits":"1",},
{"lineNum":"  102","line":"            config.timer_wheel_size,","class":"lineCov","hits":"1","order":"681","possible_hits":"1",},
{"lineNum":"  103","line":"            config.timer_capacity);","class":"linePartCov","hits":"1","order":"682","possible_hits":"2",},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"        // Create cross thread notification queue"},
{"lineNum":"  106","line":"        let notify = try!(Notify::with_capacity(config.notify_capacity));","class":"linePartCov","hits":"2","order":"820","possible_hits":"5",},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"        // Register the notification wakeup FD with the IO poller"},
{"lineNum":"  109","line":"        try!(poll.register(&notify, NOTIFY, EventSet::readable() | EventSet::writable() , PollOpt::edge()));","class":"lineCov","hits":"2","order":"887","possible_hits":"2",},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"        // Set the timer\'s starting time reference point"},
{"lineNum":"  112","line":"        timer.setup();","class":"lineCov","hits":"1","order":"1002","possible_hits":"1",},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"        Ok(EventLoop {","class":"lineCov","hits":"1","order":"1023","possible_hits":"1",},
{"lineNum":"  115","line":"            run: true,","class":"lineCov","hits":"1","order":"1024","possible_hits":"1",},
{"lineNum":"  116","line":"            poll: poll,","class":"lineCov","hits":"1","order":"1025","possible_hits":"1",},
{"lineNum":"  117","line":"            timer: timer,","class":"lineCov","hits":"1","order":"1026","possible_hits":"1",},
{"lineNum":"  118","line":"            notify: notify,"},
{"lineNum":"  119","line":"            config: config,","class":"lineCov","hits":"1","order":"1027","possible_hits":"1",},
{"lineNum":"  120","line":"        })"},
{"lineNum":"  121","line":"    }"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"    /// Returns a sender that allows sending messages to the event loop in a"},
{"lineNum":"  124","line":"    /// thread-safe way, waking up the event loop if needed."},
{"lineNum":"  125","line":"    ///"},
{"lineNum":"  126","line":"    /// # Example"},
{"lineNum":"  127","line":"    /// ```"},
{"lineNum":"  128","line":"    /// use std::thread;"},
{"lineNum":"  129","line":"    /// use mio::{EventLoop, Handler};"},
{"lineNum":"  130","line":"    ///"},
{"lineNum":"  131","line":"    /// struct MyHandler;"},
{"lineNum":"  132","line":"    ///"},
{"lineNum":"  133","line":"    /// impl Handler for MyHandler {"},
{"lineNum":"  134","line":"    ///     type Timeout = ();"},
{"lineNum":"  135","line":"    ///     type Message = u32;"},
{"lineNum":"  136","line":"    ///"},
{"lineNum":"  137","line":"    ///     fn notify(&mut self, event_loop: &mut EventLoop<MyHandler>, msg: u32) {"},
{"lineNum":"  138","line":"    ///         assert_eq!(msg, 123);"},
{"lineNum":"  139","line":"    ///         event_loop.shutdown();"},
{"lineNum":"  140","line":"    ///     }"},
{"lineNum":"  141","line":"    /// }"},
{"lineNum":"  142","line":"    ///"},
{"lineNum":"  143","line":"    /// let mut event_loop = EventLoop::new().unwrap();"},
{"lineNum":"  144","line":"    /// let sender = event_loop.channel();"},
{"lineNum":"  145","line":"    ///"},
{"lineNum":"  146","line":"    /// // Send the notification from another thread"},
{"lineNum":"  147","line":"    /// thread::spawn(move || {"},
{"lineNum":"  148","line":"    ///     let _ = sender.send(123);"},
{"lineNum":"  149","line":"    /// });"},
{"lineNum":"  150","line":"    ///"},
{"lineNum":"  151","line":"    /// let _ = event_loop.run(&mut MyHandler);"},
{"lineNum":"  152","line":"    /// ```"},
{"lineNum":"  153","line":"    ///"},
{"lineNum":"  154","line":"    /// # Implementation Details"},
{"lineNum":"  155","line":"    ///"},
{"lineNum":"  156","line":"    /// Each [EventLoop](#) contains a lock-free queue with a pre-allocated"},
{"lineNum":"  157","line":"    /// buffer size. The size can be changed by modifying"},
{"lineNum":"  158","line":"    /// [EventLoopConfig.notify_capacity](struct.EventLoopConfig.html#method.notify_capacity)."},
{"lineNum":"  159","line":"    /// When a message is sent to the EventLoop, it is first pushed on to the"},
{"lineNum":"  160","line":"    /// queue. Then, if the EventLoop is currently running, an atomic flag is"},
{"lineNum":"  161","line":"    /// set to indicate that the next loop iteration should be started without"},
{"lineNum":"  162","line":"    /// waiting."},
{"lineNum":"  163","line":"    ///"},
{"lineNum":"  164","line":"    /// If the loop is blocked waiting for IO events, then it is woken up. The"},
{"lineNum":"  165","line":"    /// strategy for waking up the event loop is platform dependent. For"},
{"lineNum":"  166","line":"    /// example, on a modern Linux OS, eventfd is used. On older OSes, a pipe"},
{"lineNum":"  167","line":"    /// is used."},
{"lineNum":"  168","line":"    ///"},
{"lineNum":"  169","line":"    /// The strategy of setting an atomic flag if the event loop is not already"},
{"lineNum":"  170","line":"    /// sleeping allows avoiding an expensive wakeup operation if at all possible."},
{"lineNum":"  171","line":"    pub fn channel(&self) -> Sender<H::Message> {"},
{"lineNum":"  172","line":"        Sender::new(self.notify.clone())"},
{"lineNum":"  173","line":"    }"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"    /// Schedules a timeout after the requested time interval. When the"},
{"lineNum":"  176","line":"    /// duration has been reached,"},
{"lineNum":"  177","line":"    /// [Handler::timeout](trait.Handler.html#method.timeout) will be invoked"},
{"lineNum":"  178","line":"    /// passing in the supplied token."},
{"lineNum":"  179","line":"    ///"},
{"lineNum":"  180","line":"    /// Returns a handle to the timeout that can be used to cancel the timeout"},
{"lineNum":"  181","line":"    /// using [#clear_timeout](#method.clear_timeout)."},
{"lineNum":"  182","line":"    ///"},
{"lineNum":"  183","line":"    /// # Example"},
{"lineNum":"  184","line":"    /// ```"},
{"lineNum":"  185","line":"    /// use mio::{EventLoop, Handler};"},
{"lineNum":"  186","line":"    ///"},
{"lineNum":"  187","line":"    /// struct MyHandler;"},
{"lineNum":"  188","line":"    ///"},
{"lineNum":"  189","line":"    /// impl Handler for MyHandler {"},
{"lineNum":"  190","line":"    ///     type Timeout = u32;"},
{"lineNum":"  191","line":"    ///     type Message = ();"},
{"lineNum":"  192","line":"    ///"},
{"lineNum":"  193","line":"    ///     fn timeout(&mut self, event_loop: &mut EventLoop<MyHandler>, timeout: u32) {"},
{"lineNum":"  194","line":"    ///         assert_eq!(timeout, 123);"},
{"lineNum":"  195","line":"    ///         event_loop.shutdown();"},
{"lineNum":"  196","line":"    ///     }"},
{"lineNum":"  197","line":"    /// }"},
{"lineNum":"  198","line":"    ///"},
{"lineNum":"  199","line":"    ///"},
{"lineNum":"  200","line":"    /// let mut event_loop = EventLoop::new().unwrap();"},
{"lineNum":"  201","line":"    /// let timeout = event_loop.timeout_ms(123, 300).unwrap();"},
{"lineNum":"  202","line":"    /// let _ = event_loop.run(&mut MyHandler);"},
{"lineNum":"  203","line":"    /// ```"},
{"lineNum":"  204","line":"    pub fn timeout_ms(&mut self, token: H::Timeout, delay: u64) -> TimerResult<Timeout> {"},
{"lineNum":"  205","line":"        self.timer.timeout_ms(token, delay)"},
{"lineNum":"  206","line":"    }"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"    /// If the supplied timeout has not been triggered, cancel it such that it"},
{"lineNum":"  209","line":"    /// will not be triggered in the future."},
{"lineNum":"  210","line":"    pub fn clear_timeout(&mut self, timeout: Timeout) -> bool {"},
{"lineNum":"  211","line":"        self.timer.clear(timeout)"},
{"lineNum":"  212","line":"    }"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"    /// Tells the event loop to exit after it is done handling all events in the"},
{"lineNum":"  215","line":"    /// current iteration."},
{"lineNum":"  216","line":"    pub fn shutdown(&mut self) {","class":"linePartCov","hits":"2","order":"1868","possible_hits":"3",},
{"lineNum":"  217","line":"        self.run = false;","class":"lineCov","hits":"1","order":"1869","possible_hits":"1",},
{"lineNum":"  218","line":"    }"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"    /// Indicates whether the event loop is currently running. If it\'s not it has either"},
{"lineNum":"  221","line":"    /// stopped or is scheduled to stop on the next tick."},
{"lineNum":"  222","line":"    pub fn is_running(&self) -> bool {"},
{"lineNum":"  223","line":"        self.run"},
{"lineNum":"  224","line":"    }"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"    /// Registers an IO handle with the event loop."},
{"lineNum":"  227","line":"    pub fn register<E: ?Sized>(&mut self, io: &E, token: Token, interest: EventSet, opt: PollOpt) -> io::Result<()>"},
{"lineNum":"  228","line":"        where E: Evented"},
{"lineNum":"  229","line":"    {","class":"linePartCov","hits":"4","order":"1158","possible_hits":"6",},
{"lineNum":"  230","line":"        self.poll.register(io, token, interest, opt)","class":"lineCov","hits":"2","order":"1159","possible_hits":"2",},
{"lineNum":"  231","line":"    }"},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"    /// Re-Registers an IO handle with the event loop."},
{"lineNum":"  234","line":"    pub fn reregister<E: ?Sized>(&mut self, io: &E, token: Token, interest: EventSet, opt: PollOpt) -> io::Result<()>"},
{"lineNum":"  235","line":"        where E: Evented"},
{"lineNum":"  236","line":"    {","class":"linePartCov","hits":"2","order":"1737","possible_hits":"3",},
{"lineNum":"  237","line":"        self.poll.reregister(io, token, interest, opt)","class":"lineCov","hits":"1","order":"1738","possible_hits":"1",},
{"lineNum":"  238","line":"    }"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"    /// Keep spinning the event loop indefinitely, and notify the handler whenever"},
{"lineNum":"  241","line":"    /// any of the registered handles are ready."},
{"lineNum":"  242","line":"    pub fn run(&mut self, handler: &mut H) -> io::Result<()> {","class":"lineCov","hits":"2","order":"1221","possible_hits":"2",},
{"lineNum":"  243","line":"        self.run = true;","class":"lineCov","hits":"1","order":"1222","possible_hits":"1",},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"        while self.run {","class":"lineCov","hits":"2","order":"1223","possible_hits":"2",},
{"lineNum":"  246","line":"            // Execute ticks as long as the event loop is running"},
{"lineNum":"  247","line":"            try!(self.run_once(handler, None));","class":"lineCov","hits":"1","order":"1224","possible_hits":"1",},
{"lineNum":"  248","line":"        }"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"        Ok(())"},
{"lineNum":"  251","line":"    }"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"    /// Deregisters an IO handle with the event loop."},
{"lineNum":"  254","line":"    pub fn deregister<E: ?Sized>(&mut self, io: &E) -> io::Result<()> where E: Evented {"},
{"lineNum":"  255","line":"        self.poll.deregister(io)"},
{"lineNum":"  256","line":"    }"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"    /// Spin the event loop once, with a timeout of one second, and notify the"},
{"lineNum":"  259","line":"    /// handler if any of the registered handles become ready during that"},
{"lineNum":"  260","line":"    /// time."},
{"lineNum":"  261","line":"    pub fn run_once(&mut self, handler: &mut H, mut timeout_ms: Option<usize>) -> io::Result<()> {","class":"linePartCov","hits":"2","order":"1225","possible_hits":"3",},
{"lineNum":"  262","line":"        let mut messages;"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"        trace!(\"event loop tick\");"},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"        // Check the notify channel for any pending messages. If there are any,"},
{"lineNum":"  267","line":"        // avoid blocking when polling for IO events. Messages will be"},
{"lineNum":"  268","line":"        // processed after IO events."},
{"lineNum":"  269","line":"        messages = self.notify.check(self.config.messages_per_tick, true);","class":"lineCov","hits":"1","order":"1226","possible_hits":"1",},
{"lineNum":"  270","line":"        let pending = messages > 0;","class":"lineCov","hits":"1","order":"1248","possible_hits":"1",},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"        if pending {","class":"lineCov","hits":"1","order":"1249","possible_hits":"1",},
{"lineNum":"  273","line":"            timeout_ms = Some(0);"},
{"lineNum":"  274","line":"        }"},
{"lineNum":"  275","line":""},
{"lineNum":"  276","line":"        // Check the registered IO handles for any new events. Each poll"},
{"lineNum":"  277","line":"        // is for one second, so a shutdown request can last as long as"},
{"lineNum":"  278","line":"        // one second before it takes effect."},
{"lineNum":"  279","line":"        let events = match self.io_poll(timeout_ms) {","class":"linePartCov","hits":"1","order":"1250","possible_hits":"4",},
{"lineNum":"  280","line":"            Ok(e) => e,","class":"lineCov","hits":"1","order":"1278","possible_hits":"1",},
{"lineNum":"  281","line":"            Err(err) => {"},
{"lineNum":"  282","line":"                if err.kind() == io::ErrorKind::Interrupted {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  283","line":"                    handler.interrupted(self);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  284","line":"                    0","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  285","line":"                } else {"},
{"lineNum":"  286","line":"                    return Err(err);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  287","line":"                }"},
{"lineNum":"  288","line":"            }"},
{"lineNum":"  289","line":"        };"},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"        if !pending {","class":"lineCov","hits":"1","order":"1279","possible_hits":"1",},
{"lineNum":"  292","line":"            // Indicate that the sleep period is over, also grab any additional"},
{"lineNum":"  293","line":"            // messages"},
{"lineNum":"  294","line":"            let remaining = self.config.messages_per_tick - messages;","class":"linePartCov","hits":"1","order":"1280","possible_hits":"2",},
{"lineNum":"  295","line":"            messages += self.notify.check(remaining, false);","class":"lineCov","hits":"2","order":"1281","possible_hits":"2",},
{"lineNum":"  296","line":"        }"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"        self.io_process(handler, events);","class":"lineCov","hits":"1","order":"1284","possible_hits":"1",},
{"lineNum":"  299","line":"        self.notify(handler, messages);","class":"lineCov","hits":"1","order":"1613","possible_hits":"1",},
{"lineNum":"  300","line":"        self.timer_process(handler);","class":"lineCov","hits":"1","order":"1616","possible_hits":"1",},
{"lineNum":"  301","line":"        handler.tick(self);","class":"lineCov","hits":"1","order":"1634","possible_hits":"1",},
{"lineNum":"  302","line":"        Ok(())"},
{"lineNum":"  303","line":"    }"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"    #[inline]"},
{"lineNum":"  306","line":"    fn io_poll(&mut self, timeout: Option<usize>) -> io::Result<usize> {","class":"linePartCov","hits":"2","order":"1251","possible_hits":"3",},
{"lineNum":"  307","line":"        let next_tick = self.timer.next_tick_in_ms()","class":"lineCov","hits":"1","order":"1252","possible_hits":"1",},
{"lineNum":"  308","line":"            .map(|ms| cmp::min(ms, usize::MAX as u64) as usize);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  309","line":""},
{"lineNum":"  310","line":"        let timeout = match (timeout, next_tick) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  311","line":"            (Some(a), Some(b)) => Some(cmp::min(a, b)),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  312","line":"            (Some(a), None) => Some(a),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  313","line":"            (None, Some(b)) => Some(b),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  314","line":"            _ => None,"},
{"lineNum":"  315","line":"        };"},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"        self.poll.poll(timeout)","class":"lineCov","hits":"1","order":"1258","possible_hits":"1",},
{"lineNum":"  318","line":"    }"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"    // Process IO events that have been previously polled"},
{"lineNum":"  321","line":"    fn io_process(&mut self, handler: &mut H, cnt: usize) {","class":"lineCov","hits":"2","order":"1285","possible_hits":"2",},
{"lineNum":"  322","line":"        let mut i = 0;","class":"lineCov","hits":"1","order":"1286","possible_hits":"1",},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"        // Iterate over the notifications. Each event provides the token"},
{"lineNum":"  325","line":"        // it was registered with (which usually represents, at least, the"},
{"lineNum":"  326","line":"        // handle that the event is about) as well as information about"},
{"lineNum":"  327","line":"        // what kind of event occurred (readable, writable, signal, etc.)"},
{"lineNum":"  328","line":"        while i < cnt {","class":"lineCov","hits":"2","order":"1287","possible_hits":"2",},
{"lineNum":"  329","line":"            let evt = self.poll.event(i);","class":"lineCov","hits":"1","order":"1288","possible_hits":"1",},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"            trace!(\"event={:?}\", evt);"},
{"lineNum":"  332","line":""},
{"lineNum":"  333","line":"            match evt.token {","class":"lineCov","hits":"1","order":"1317","possible_hits":"1",},
{"lineNum":"  334","line":"                NOTIFY => self.notify.cleanup(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  335","line":"                _ => self.io_event(handler, evt)","class":"lineCov","hits":"1","order":"1318","possible_hits":"1",},
{"lineNum":"  336","line":"            }"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"            i += 1;","class":"linePartCov","hits":"1","order":"1612","possible_hits":"2",},
{"lineNum":"  339","line":"        }"},
{"lineNum":"  340","line":"    }"},
{"lineNum":"  341","line":""},
{"lineNum":"  342","line":"    fn io_event(&mut self, handler: &mut H, evt: IoEvent) {","class":"linePartCov","hits":"2","order":"1319","possible_hits":"3",},
{"lineNum":"  343","line":"        handler.ready(self, evt.token, evt.kind);","class":"lineCov","hits":"1","order":"1320","possible_hits":"1",},
{"lineNum":"  344","line":"    }"},
{"lineNum":"  345","line":""},
{"lineNum":"  346","line":"    fn notify(&mut self, handler: &mut H, mut cnt: usize) {","class":"lineCov","hits":"2","order":"1614","possible_hits":"2",},
{"lineNum":"  347","line":"        while cnt > 0 {","class":"lineCov","hits":"2","order":"1615","possible_hits":"2",},
{"lineNum":"  348","line":"            match self.notify.poll() {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  349","line":"                Some(msg) => {"},
{"lineNum":"  350","line":"                    handler.notify(self, msg);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  351","line":"                    cnt -= 1;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  352","line":"                },"},
{"lineNum":"  353","line":"                // If we expect messages, but the queue seems empty, a context"},
{"lineNum":"  354","line":"                // switch has occurred in the queue\'s push() method between"},
{"lineNum":"  355","line":"                // reserving a slot and marking that slot; let\'s spin for"},
{"lineNum":"  356","line":"                // what should be a very brief period of time until the push"},
{"lineNum":"  357","line":"                // is done."},
{"lineNum":"  358","line":"                None => thread::yield_now(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  359","line":"            }"},
{"lineNum":"  360","line":"        }"},
{"lineNum":"  361","line":"    }"},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":"    fn timer_process(&mut self, handler: &mut H) {","class":"lineCov","hits":"2","order":"1617","possible_hits":"2",},
{"lineNum":"  364","line":"        let now = self.timer.now();","class":"lineCov","hits":"1","order":"1618","possible_hits":"1",},
{"lineNum":"  365","line":""},
{"lineNum":"  366","line":"        loop {","class":"lineCov","hits":"1","order":"1623","possible_hits":"1",},
{"lineNum":"  367","line":"            match self.timer.tick_to(now) {","class":"lineCov","hits":"1","order":"1624","possible_hits":"1",},
{"lineNum":"  368","line":"                Some(t) => handler.timeout(self, t),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  369","line":"                _ => return","class":"linePartCov","hits":"1","order":"1633","possible_hits":"2",},
{"lineNum":"  370","line":"            }"},
{"lineNum":"  371","line":"        }"},
{"lineNum":"  372","line":"    }"},
{"lineNum":"  373","line":"}"},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"unsafe impl<H: Handler> Sync for EventLoop<H> { }"},
{"lineNum":"  376","line":""},
{"lineNum":"  377","line":"impl <H: Handler> Drop for EventLoop<H> {"},
{"lineNum":"  378","line":"    fn drop(&mut self) {","class":"linePartCov","hits":"2","order":"1969","possible_hits":"3",},
{"lineNum":"  379","line":"        self.notify.close();","class":"lineCov","hits":"1","order":"1970","possible_hits":"1",},
{"lineNum":"  380","line":"    }"},
{"lineNum":"  381","line":"}"},
{"lineNum":"  382","line":""},
{"lineNum":"  383","line":"/// Sends messages to the EventLoop from other threads."},
{"lineNum":"  384","line":"pub struct Sender<M: Send> {"},
{"lineNum":"  385","line":"    notify: Notify<M>"},
{"lineNum":"  386","line":"}"},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"impl<M: Send> Clone for Sender<M> {"},
{"lineNum":"  389","line":"    fn clone(&self) -> Sender<M> {"},
{"lineNum":"  390","line":"        Sender { notify: self.notify.clone() }"},
{"lineNum":"  391","line":"    }"},
{"lineNum":"  392","line":"}"},
{"lineNum":"  393","line":""},
{"lineNum":"  394","line":"impl<M: Send> fmt::Debug for Sender<M> {"},
{"lineNum":"  395","line":"    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  396","line":"        write!(fmt, \"Sender<?> {{ ... }}\")"},
{"lineNum":"  397","line":"    }"},
{"lineNum":"  398","line":"}"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":"unsafe impl<M: Send> Sync for Sender<M> { }"},
{"lineNum":"  401","line":""},
{"lineNum":"  402","line":"impl<M: Send> Sender<M> {"},
{"lineNum":"  403","line":"    fn new(notify: Notify<M>) -> Sender<M> {"},
{"lineNum":"  404","line":"        Sender { notify: notify }"},
{"lineNum":"  405","line":"    }"},
{"lineNum":"  406","line":""},
{"lineNum":"  407","line":"    pub fn send(&self, msg: M) -> Result<(), NotifyError<M>> {"},
{"lineNum":"  408","line":"        self.notify.notify(msg)"},
{"lineNum":"  409","line":"    }"},
{"lineNum":"  410","line":"}"},
{"lineNum":"  411","line":""},
{"lineNum":"  412","line":"#[cfg(test)]"},
{"lineNum":"  413","line":"#[cfg(unix)]"},
{"lineNum":"  414","line":"mod tests {"},
{"lineNum":"  415","line":"    use std::str;"},
{"lineNum":"  416","line":"    use std::sync::Arc;"},
{"lineNum":"  417","line":"    use std::sync::atomic::AtomicIsize;"},
{"lineNum":"  418","line":"    use std::sync::atomic::Ordering::SeqCst;"},
{"lineNum":"  419","line":"    use super::EventLoop;"},
{"lineNum":"  420","line":"    use {unix, Handler, Token, TryRead, TryWrite, EventSet, PollOpt};"},
{"lineNum":"  421","line":"    use bytes::{Buf, SliceBuf, ByteBuf};"},
{"lineNum":"  422","line":""},
{"lineNum":"  423","line":"    #[test]"},
{"lineNum":"  424","line":"    pub fn test_event_loop_size() {"},
{"lineNum":"  425","line":"        use std::mem;"},
{"lineNum":"  426","line":"        assert!(512 >= mem::size_of::<EventLoop<Funtimes>>());"},
{"lineNum":"  427","line":"    }"},
{"lineNum":"  428","line":""},
{"lineNum":"  429","line":"    struct Funtimes {"},
{"lineNum":"  430","line":"        rcount: Arc<AtomicIsize>,"},
{"lineNum":"  431","line":"        wcount: Arc<AtomicIsize>"},
{"lineNum":"  432","line":"    }"},
{"lineNum":"  433","line":""},
{"lineNum":"  434","line":"    impl Funtimes {"},
{"lineNum":"  435","line":"        fn new(rcount: Arc<AtomicIsize>, wcount: Arc<AtomicIsize>) -> Funtimes {"},
{"lineNum":"  436","line":"            Funtimes {"},
{"lineNum":"  437","line":"                rcount: rcount,"},
{"lineNum":"  438","line":"                wcount: wcount"},
{"lineNum":"  439","line":"            }"},
{"lineNum":"  440","line":"        }"},
{"lineNum":"  441","line":"    }"},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":"    impl Handler for Funtimes {"},
{"lineNum":"  444","line":"        type Timeout = usize;"},
{"lineNum":"  445","line":"        type Message = ();"},
{"lineNum":"  446","line":""},
{"lineNum":"  447","line":"        fn ready(&mut self, _event_loop: &mut EventLoop<Funtimes>, token: Token, events: EventSet) {"},
{"lineNum":"  448","line":"            if events.is_readable() {"},
{"lineNum":"  449","line":"                (*self.rcount).fetch_add(1, SeqCst);"},
{"lineNum":"  450","line":"                assert_eq!(token, Token(10));"},
{"lineNum":"  451","line":"            }"},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"            if events.is_writable() {"},
{"lineNum":"  454","line":"                (*self.wcount).fetch_add(1, SeqCst);"},
{"lineNum":"  455","line":"                assert_eq!(token, Token(10));"},
{"lineNum":"  456","line":"            }"},
{"lineNum":"  457","line":"        }"},
{"lineNum":"  458","line":"    }"},
{"lineNum":"  459","line":""},
{"lineNum":"  460","line":"    #[test]"},
{"lineNum":"  461","line":"    pub fn test_readable() {"},
{"lineNum":"  462","line":"        let mut event_loop = EventLoop::new().ok().expect(\"Couldn\'t make event loop\");"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"        let (mut reader, mut writer) = unix::pipe().unwrap();"},
{"lineNum":"  465","line":""},
{"lineNum":"  466","line":"        let rcount = Arc::new(AtomicIsize::new(0));"},
{"lineNum":"  467","line":"        let wcount = Arc::new(AtomicIsize::new(0));"},
{"lineNum":"  468","line":"        let mut handler = Funtimes::new(rcount.clone(), wcount.clone());"},
{"lineNum":"  469","line":""},
{"lineNum":"  470","line":"        writer.try_write_buf(&mut SliceBuf::wrap(\"hello\".as_bytes())).unwrap();"},
{"lineNum":"  471","line":"        event_loop.register(&reader, Token(10), EventSet::readable(),"},
{"lineNum":"  472","line":"                            PollOpt::edge()).unwrap();"},
{"lineNum":"  473","line":""},
{"lineNum":"  474","line":"        let _ = event_loop.run_once(&mut handler, None);"},
{"lineNum":"  475","line":"        let mut b = ByteBuf::mut_with_capacity(16);"},
{"lineNum":"  476","line":""},
{"lineNum":"  477","line":"        assert_eq!((*rcount).load(SeqCst), 1);"},
{"lineNum":"  478","line":""},
{"lineNum":"  479","line":"        reader.try_read_buf(&mut b).unwrap();"},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"        assert_eq!(str::from_utf8(b.flip().bytes()).unwrap(), \"hello\");"},
{"lineNum":"  482","line":"    }"},
{"lineNum":"  483","line":""},
{"lineNum":"  484","line":"    pub struct BrokenPipeHandler;"},
{"lineNum":"  485","line":""},
{"lineNum":"  486","line":"    impl Handler for BrokenPipeHandler {"},
{"lineNum":"  487","line":"        type Timeout = ();"},
{"lineNum":"  488","line":"        type Message = ();"},
{"lineNum":"  489","line":"        fn ready(&mut self, _: &mut EventLoop<Self>, token: Token, _: EventSet) {"},
{"lineNum":"  490","line":"            if token == Token(1) {"},
{"lineNum":"  491","line":"                panic!(\"Received ready() on a closed pipe.\");"},
{"lineNum":"  492","line":"            }"},
{"lineNum":"  493","line":"        }"},
{"lineNum":"  494","line":"    }"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":"    #[test]"},
{"lineNum":"  497","line":"    pub fn broken_pipe() {"},
{"lineNum":"  498","line":"        let mut event_loop: EventLoop<BrokenPipeHandler> = EventLoop::new().unwrap();"},
{"lineNum":"  499","line":"        let (reader, _) = unix::pipe().unwrap();"},
{"lineNum":"  500","line":""},
{"lineNum":"  501","line":"        // On Darwin this returns a \"broken pipe\" error."},
{"lineNum":"  502","line":"        let _ = event_loop.register(&reader, Token(1), EventSet::all(), PollOpt::edge());"},
{"lineNum":"  503","line":""},
{"lineNum":"  504","line":"        let mut handler = BrokenPipeHandler;"},
{"lineNum":"  505","line":"        drop(reader);"},
{"lineNum":"  506","line":"        event_loop.run_once(&mut handler, Some(1000)).unwrap();"},
{"lineNum":"  507","line":"    }"},
{"lineNum":"  508","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test_mio-b9fce113d2acf305", "date" : "2016-02-17 13:45:59", "instrumented" : 79, "covered" : 62,};
var merged_data = [];
