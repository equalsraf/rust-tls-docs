var data = {lines:[
{"lineNum":"    1","line":"/* Copyright (c) 2010-2011 Dmitry Vyukov. All rights reserved."},
{"lineNum":"    2","line":" * Redistribution and use in source and binary forms, with or without"},
{"lineNum":"    3","line":" * modification, are permitted provided that the following conditions are met:"},
{"lineNum":"    4","line":" *"},
{"lineNum":"    5","line":" *    1. Redistributions of source code must retain the above copyright notice,"},
{"lineNum":"    6","line":" *       this list of conditions and the following disclaimer."},
{"lineNum":"    7","line":" *"},
{"lineNum":"    8","line":" *    2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"    9","line":" *       notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   10","line":" *       documentation and/or other materials provided with the distribution."},
{"lineNum":"   11","line":" *"},
{"lineNum":"   12","line":" * THIS SOFTWARE IS PROVIDED BY DMITRY VYUKOV \"AS IS\" AND ANY EXPRESS OR IMPLIED"},
{"lineNum":"   13","line":" * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF"},
{"lineNum":"   14","line":" * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT"},
{"lineNum":"   15","line":" * SHALL DMITRY VYUKOV OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,"},
{"lineNum":"   16","line":" * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT"},
{"lineNum":"   17","line":" * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   18","line":" * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   19","line":" * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE"},
{"lineNum":"   20","line":" * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF"},
{"lineNum":"   21","line":" * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   22","line":" *"},
{"lineNum":"   23","line":" * The views and conclusions contained in the software and documentation are"},
{"lineNum":"   24","line":" * those of the authors and should not be interpreted as representing official"},
{"lineNum":"   25","line":" * policies, either expressed or implied, of Dmitry Vyukov."},
{"lineNum":"   26","line":" */"},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"#![allow(missing_docs, dead_code)]"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"// http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"// This queue is copy pasted from old rust stdlib."},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"use std::sync::Arc;"},
{"lineNum":"   35","line":"use std::cell::UnsafeCell;"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"use std::sync::atomic::AtomicUsize;"},
{"lineNum":"   38","line":"use std::sync::atomic::Ordering::{Relaxed, Release, Acquire};"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"struct Node<T> {"},
{"lineNum":"   41","line":"    sequence: AtomicUsize,"},
{"lineNum":"   42","line":"    value: Option<T>,"},
{"lineNum":"   43","line":"}"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"unsafe impl<T: Send> Send for Node<T> {}"},
{"lineNum":"   46","line":"unsafe impl<T: Sync> Sync for Node<T> {}"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"struct State<T> {"},
{"lineNum":"   49","line":"    pad0: [u8; 64],"},
{"lineNum":"   50","line":"    buffer: Vec<UnsafeCell<Node<T>>>,"},
{"lineNum":"   51","line":"    mask: usize,"},
{"lineNum":"   52","line":"    pad1: [u8; 64],"},
{"lineNum":"   53","line":"    enqueue_pos: AtomicUsize,"},
{"lineNum":"   54","line":"    pad2: [u8; 64],"},
{"lineNum":"   55","line":"    dequeue_pos: AtomicUsize,"},
{"lineNum":"   56","line":"    pad3: [u8; 64],"},
{"lineNum":"   57","line":"}"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"unsafe impl<T: Send> Send for State<T> {}"},
{"lineNum":"   60","line":"unsafe impl<T: Sync> Sync for State<T> {}"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"pub struct Queue<T> {"},
{"lineNum":"   63","line":"    state: Arc<State<T>>,"},
{"lineNum":"   64","line":"}"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"impl<T: Send> State<T> {"},
{"lineNum":"   67","line":"    fn with_capacity(capacity: usize) -> State<T> {","class":"linePartCov","hits":"2","order":"828","possible_hits":"3",},
{"lineNum":"   68","line":"        let capacity = if capacity < 2 || (capacity & (capacity - 1)) != 0 {","class":"lineCov","hits":"1","order":"829","possible_hits":"1",},
{"lineNum":"   69","line":"            if capacity < 2 {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   70","line":"                2","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   71","line":"            } else {"},
{"lineNum":"   72","line":"                // use next power of 2 as capacity"},
{"lineNum":"   73","line":"                capacity.next_power_of_two()","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   74","line":"            }"},
{"lineNum":"   75","line":"        } else {"},
{"lineNum":"   76","line":"            capacity","class":"lineCov","hits":"1","order":"830","possible_hits":"1",},
{"lineNum":"   77","line":"        };"},
{"lineNum":"   78","line":"        let buffer = (0..capacity).map(|i| {","class":"linePartCov","hits":"3","order":"831","possible_hits":"4",},
{"lineNum":"   79","line":"            UnsafeCell::new(Node { sequence:AtomicUsize::new(i), value: None })","class":"lineCov","hits":"1","order":"832","possible_hits":"1",},
{"lineNum":"   80","line":"        }).collect::<Vec<_>>();"},
{"lineNum":"   81","line":"        State{","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   82","line":"            pad0: [0; 64],"},
{"lineNum":"   83","line":"            buffer: buffer,"},
{"lineNum":"   84","line":"            mask: capacity-1,","class":"lineCov","hits":"1","order":"836","possible_hits":"1",},
{"lineNum":"   85","line":"            pad1: [0; 64],"},
{"lineNum":"   86","line":"            enqueue_pos: AtomicUsize::new(0),"},
{"lineNum":"   87","line":"            pad2: [0; 64],"},
{"lineNum":"   88","line":"            dequeue_pos: AtomicUsize::new(0),"},
{"lineNum":"   89","line":"            pad3: [0; 64],"},
{"lineNum":"   90","line":"        }"},
{"lineNum":"   91","line":"    }"},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"    fn push(&self, value: T) -> Result<(), T> {"},
{"lineNum":"   94","line":"        let mask = self.mask;"},
{"lineNum":"   95","line":"        let mut pos = self.enqueue_pos.load(Relaxed);"},
{"lineNum":"   96","line":"        loop {"},
{"lineNum":"   97","line":"            let node = &self.buffer[pos & mask];"},
{"lineNum":"   98","line":"            let seq = unsafe { (*node.get()).sequence.load(Acquire) };"},
{"lineNum":"   99","line":"            let diff: isize = seq as isize - pos as isize;"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"            if diff == 0 {"},
{"lineNum":"  102","line":"                let enqueue_pos = self.enqueue_pos.compare_and_swap(pos, pos+1, Relaxed);"},
{"lineNum":"  103","line":"                if enqueue_pos == pos {"},
{"lineNum":"  104","line":"                    unsafe {"},
{"lineNum":"  105","line":"                        (*node.get()).value = Some(value);"},
{"lineNum":"  106","line":"                        (*node.get()).sequence.store(pos+1, Release);"},
{"lineNum":"  107","line":"                    }"},
{"lineNum":"  108","line":"                    break"},
{"lineNum":"  109","line":"                } else {"},
{"lineNum":"  110","line":"                    pos = enqueue_pos;"},
{"lineNum":"  111","line":"                }"},
{"lineNum":"  112","line":"            } else if diff < 0 {"},
{"lineNum":"  113","line":"                return Err(value);"},
{"lineNum":"  114","line":"            } else {"},
{"lineNum":"  115","line":"                pos = self.enqueue_pos.load(Relaxed);"},
{"lineNum":"  116","line":"            }"},
{"lineNum":"  117","line":"        }"},
{"lineNum":"  118","line":"        Ok(())"},
{"lineNum":"  119","line":"    }"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"    fn pop(&self) -> Option<T> {","class":"lineCov","hits":"2","order":"1979","possible_hits":"2",},
{"lineNum":"  122","line":"        let mask = self.mask;","class":"lineCov","hits":"1","order":"1980","possible_hits":"1",},
{"lineNum":"  123","line":"        let mut pos = self.dequeue_pos.load(Relaxed);","class":"lineCov","hits":"1","order":"1981","possible_hits":"1",},
{"lineNum":"  124","line":"        loop {","class":"lineCov","hits":"1","order":"1982","possible_hits":"1",},
{"lineNum":"  125","line":"            let node = &self.buffer[pos & mask];","class":"lineCov","hits":"1","order":"1983","possible_hits":"1",},
{"lineNum":"  126","line":"            let seq = unsafe { (*node.get()).sequence.load(Acquire) };","class":"lineCov","hits":"1","order":"1984","possible_hits":"1",},
{"lineNum":"  127","line":"            let diff: isize = seq as isize - (pos + 1) as isize;","class":"linePartCov","hits":"1","order":"1986","possible_hits":"2",},
{"lineNum":"  128","line":"            if diff == 0 {","class":"lineCov","hits":"1","order":"1987","possible_hits":"1",},
{"lineNum":"  129","line":"                let dequeue_pos = self.dequeue_pos.compare_and_swap(pos, pos+1, Relaxed);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  130","line":"                if dequeue_pos == pos {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  131","line":"                    unsafe {"},
{"lineNum":"  132","line":"                        let value = (*node.get()).value.take();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  133","line":"                        (*node.get()).sequence.store(pos + mask + 1, Release);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  134","line":"                        return value","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  135","line":"                    }"},
{"lineNum":"  136","line":"                } else {"},
{"lineNum":"  137","line":"                    pos = dequeue_pos;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  138","line":"                }"},
{"lineNum":"  139","line":"            } else if diff < 0 {","class":"lineCov","hits":"1","order":"1988","possible_hits":"1",},
{"lineNum":"  140","line":"                return None","class":"lineCov","hits":"1","order":"1989","possible_hits":"1",},
{"lineNum":"  141","line":"            } else {"},
{"lineNum":"  142","line":"                pos = self.dequeue_pos.load(Relaxed);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  143","line":"            }"},
{"lineNum":"  144","line":"        }"},
{"lineNum":"  145","line":"    }"},
{"lineNum":"  146","line":"}"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"impl<T: Send> Queue<T> {"},
{"lineNum":"  149","line":"    pub fn with_capacity(capacity: usize) -> Queue<T> {","class":"linePartCov","hits":"2","order":"826","possible_hits":"3",},
{"lineNum":"  150","line":"        Queue{"},
{"lineNum":"  151","line":"            state: Arc::new(State::with_capacity(capacity))","class":"lineCov","hits":"1","order":"827","possible_hits":"1",},
{"lineNum":"  152","line":"        }"},
{"lineNum":"  153","line":"    }"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"    pub fn push(&self, value: T) -> Result<(), T> {"},
{"lineNum":"  156","line":"        self.state.push(value)"},
{"lineNum":"  157","line":"    }"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"    pub fn pop(&self) -> Option<T> {","class":"linePartCov","hits":"2","order":"1977","possible_hits":"3",},
{"lineNum":"  160","line":"        self.state.pop()","class":"lineCov","hits":"1","order":"1978","possible_hits":"1",},
{"lineNum":"  161","line":"    }"},
{"lineNum":"  162","line":"}"},
{"lineNum":"  163","line":""},
{"lineNum":"  164","line":"impl<T: Send> Clone for Queue<T> {"},
{"lineNum":"  165","line":"    fn clone(&self) -> Queue<T> {"},
{"lineNum":"  166","line":"        Queue { state: self.state.clone() }"},
{"lineNum":"  167","line":"    }"},
{"lineNum":"  168","line":"}"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"#[cfg(test)]"},
{"lineNum":"  171","line":"mod tests {"},
{"lineNum":"  172","line":"    use std::thread;"},
{"lineNum":"  173","line":"    use std::sync::mpsc::channel;"},
{"lineNum":"  174","line":"    use super::Queue;"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"    #[test]"},
{"lineNum":"  177","line":"    fn test() {"},
{"lineNum":"  178","line":"        let nthreads = 8;"},
{"lineNum":"  179","line":"        let nmsgs = 1000;"},
{"lineNum":"  180","line":"        let q = Queue::with_capacity(nthreads*nmsgs);"},
{"lineNum":"  181","line":"        assert_eq!(None, q.pop());"},
{"lineNum":"  182","line":"        let (tx, rx) = channel();"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"        for _ in 0..nthreads {"},
{"lineNum":"  185","line":"            let q = q.clone();"},
{"lineNum":"  186","line":"            let tx = tx.clone();"},
{"lineNum":"  187","line":"            thread::spawn(move || {"},
{"lineNum":"  188","line":"                let q = q;"},
{"lineNum":"  189","line":"                for i in 0..nmsgs {"},
{"lineNum":"  190","line":"                    assert!(q.push(i).is_ok());"},
{"lineNum":"  191","line":"                }"},
{"lineNum":"  192","line":"                tx.send(()).unwrap();"},
{"lineNum":"  193","line":"            });"},
{"lineNum":"  194","line":"        }"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"        let mut completion_rxs = vec![];"},
{"lineNum":"  197","line":"        for _ in 0..nthreads {"},
{"lineNum":"  198","line":"            let (tx, rx) = channel();"},
{"lineNum":"  199","line":"            completion_rxs.push(rx);"},
{"lineNum":"  200","line":"            let q = q.clone();"},
{"lineNum":"  201","line":"            thread::spawn(move || {"},
{"lineNum":"  202","line":"                let q = q;"},
{"lineNum":"  203","line":"                let mut i = 0;"},
{"lineNum":"  204","line":"                loop {"},
{"lineNum":"  205","line":"                    match q.pop() {"},
{"lineNum":"  206","line":"                        None => {},"},
{"lineNum":"  207","line":"                        Some(_) => {"},
{"lineNum":"  208","line":"                            i += 1;"},
{"lineNum":"  209","line":"                            if i == nmsgs { break }"},
{"lineNum":"  210","line":"                        }"},
{"lineNum":"  211","line":"                    }"},
{"lineNum":"  212","line":"                }"},
{"lineNum":"  213","line":"                tx.send(i).unwrap();"},
{"lineNum":"  214","line":"            });"},
{"lineNum":"  215","line":"        }"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"        for rx in completion_rxs.iter_mut() {"},
{"lineNum":"  218","line":"            assert_eq!(nmsgs, rx.recv().unwrap());"},
{"lineNum":"  219","line":"        }"},
{"lineNum":"  220","line":"        for _ in 0..nthreads {"},
{"lineNum":"  221","line":"            rx.recv().unwrap();"},
{"lineNum":"  222","line":"        }"},
{"lineNum":"  223","line":"    }"},
{"lineNum":"  224","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test_mio-b9fce113d2acf305", "date" : "2016-02-17 14:25:21", "instrumented" : 31, "covered" : 20,};
var merged_data = [];
