var data = {lines:[
{"lineNum":"    1","line":"use {EventLoop, EventSet, Token};"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"#[allow(unused_variables)]"},
{"lineNum":"    4","line":"pub trait Handler: Sized {"},
{"lineNum":"    5","line":"    type Timeout;"},
{"lineNum":"    6","line":"    type Message: Send;"},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"    /// Invoked when the socket represented by `token` is ready to be operated"},
{"lineNum":"    9","line":"    /// on. `events` indicates the specific operations that are"},
{"lineNum":"   10","line":"    /// ready to be performed."},
{"lineNum":"   11","line":"    ///"},
{"lineNum":"   12","line":"    /// For example, when a TCP socket is ready to be read from, `events` will"},
{"lineNum":"   13","line":"    /// have `readable` set. When the socket is ready to be written to,"},
{"lineNum":"   14","line":"    /// `events` will have `writable` set."},
{"lineNum":"   15","line":"    ///"},
{"lineNum":"   16","line":"    /// This function will only be invoked a single time per socket per event"},
{"lineNum":"   17","line":"    /// loop tick."},
{"lineNum":"   18","line":"    fn ready(&mut self, event_loop: &mut EventLoop<Self>, token: Token, events: EventSet) {"},
{"lineNum":"   19","line":"    }"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"    /// Invoked when a message has been received via the event loop\'s channel."},
{"lineNum":"   22","line":"    fn notify(&mut self, event_loop: &mut EventLoop<Self>, msg: Self::Message) {","class":"lineNoCov","hits":"0",},
{"lineNum":"   23","line":"    }"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"    /// Invoked when a timeout has completed."},
{"lineNum":"   26","line":"    fn timeout(&mut self, event_loop: &mut EventLoop<Self>, timeout: Self::Timeout) {","class":"lineNoCov","hits":"0",},
{"lineNum":"   27","line":"    }"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"    /// Invoked when `EventLoop` has been interrupted by a signal interrupt."},
{"lineNum":"   30","line":"    fn interrupted(&mut self, event_loop: &mut EventLoop<Self>) {","class":"lineNoCov","hits":"0",},
{"lineNum":"   31","line":"    }"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"    /// Invoked at the end of an event loop tick."},
{"lineNum":"   34","line":"    fn tick(&mut self, event_loop: &mut EventLoop<Self>) {","class":"lineCov","hits":"1","order":"1691",},
{"lineNum":"   35","line":"    }"},
{"lineNum":"   36","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test_server-9ef2987148640087", "date" : "2016-02-17 14:25:27", "instrumented" : 4, "covered" : 1,};
var merged_data = [];
