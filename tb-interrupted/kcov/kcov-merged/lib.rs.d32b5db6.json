var data = {lines:[
{"lineNum":"    1","line":"// Copyright 2015 The Rust Project Developers. See the COPYRIGHT"},
{"lineNum":"    2","line":"// file at the top-level directory of this distribution and at"},
{"lineNum":"    3","line":"// http://rust-lang.org/COPYRIGHT."},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or"},
{"lineNum":"    6","line":"// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license"},
{"lineNum":"    7","line":"// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your"},
{"lineNum":"    8","line":"// option. This file may not be copied, modified, or distributed"},
{"lineNum":"    9","line":"// except according to those terms."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"//! A lightweight logging facade."},
{"lineNum":"   12","line":"//!"},
{"lineNum":"   13","line":"//! A logging facade provides a single logging API that abstracts over the"},
{"lineNum":"   14","line":"//! actual logging implementation. Libraries can use the logging API provided"},
{"lineNum":"   15","line":"//! by this crate, and the consumer of those libraries can choose the logging"},
{"lineNum":"   16","line":"//! framework that is most suitable for its use case."},
{"lineNum":"   17","line":"//!"},
{"lineNum":"   18","line":"//! If no logging implementation is selected, the facade falls back to a \"noop\""},
{"lineNum":"   19","line":"//! implementation that ignores all log messages. The overhead in this case"},
{"lineNum":"   20","line":"//! is very small - just an integer load, comparison and jump."},
{"lineNum":"   21","line":"//!"},
{"lineNum":"   22","line":"//! A log request consists of a target, a level, and a body. A target is a"},
{"lineNum":"   23","line":"//! string which defaults to the module path of the location of the log"},
{"lineNum":"   24","line":"//! request, though that default may be overridden. Logger implementations"},
{"lineNum":"   25","line":"//! typically use the target to filter requests based on some user"},
{"lineNum":"   26","line":"//! configuration."},
{"lineNum":"   27","line":"//!"},
{"lineNum":"   28","line":"//! # Use"},
{"lineNum":"   29","line":"//!"},
{"lineNum":"   30","line":"//! ## In libraries"},
{"lineNum":"   31","line":"//!"},
{"lineNum":"   32","line":"//! Libraries should link only to the `log` crate, and use the provided"},
{"lineNum":"   33","line":"//! macros to log whatever information will be useful to downstream consumers."},
{"lineNum":"   34","line":"//!"},
{"lineNum":"   35","line":"//! ### Examples"},
{"lineNum":"   36","line":"//!"},
{"lineNum":"   37","line":"//! ```rust"},
{"lineNum":"   38","line":"//! # #![allow(unstable)]"},
{"lineNum":"   39","line":"//! #[macro_use]"},
{"lineNum":"   40","line":"//! extern crate log;"},
{"lineNum":"   41","line":"//!"},
{"lineNum":"   42","line":"//! # #[derive(Debug)] pub struct Yak(String);"},
{"lineNum":"   43","line":"//! # impl Yak { fn shave(&self, _: u32) {} }"},
{"lineNum":"   44","line":"//! # fn find_a_razor() -> Result<u32, u32> { Ok(1) }"},
{"lineNum":"   45","line":"//! pub fn shave_the_yak(yak: &Yak) {"},
{"lineNum":"   46","line":"//!     info!(target: \"yak_events\", \"Commencing yak shaving for {:?}\", yak);"},
{"lineNum":"   47","line":"//!"},
{"lineNum":"   48","line":"//!     loop {"},
{"lineNum":"   49","line":"//!         match find_a_razor() {"},
{"lineNum":"   50","line":"//!             Ok(razor) => {"},
{"lineNum":"   51","line":"//!                 info!(\"Razor located: {}\", razor);"},
{"lineNum":"   52","line":"//!                 yak.shave(razor);"},
{"lineNum":"   53","line":"//!                 break;"},
{"lineNum":"   54","line":"//!             }"},
{"lineNum":"   55","line":"//!             Err(err) => {"},
{"lineNum":"   56","line":"//!                 warn!(\"Unable to locate a razor: {}, retrying\", err);"},
{"lineNum":"   57","line":"//!             }"},
{"lineNum":"   58","line":"//!         }"},
{"lineNum":"   59","line":"//!     }"},
{"lineNum":"   60","line":"//! }"},
{"lineNum":"   61","line":"//! # fn main() {}"},
{"lineNum":"   62","line":"//! ```"},
{"lineNum":"   63","line":"//!"},
{"lineNum":"   64","line":"//! ## In executables"},
{"lineNum":"   65","line":"//!"},
{"lineNum":"   66","line":"//! Executables should choose a logging framework and initialize it early in the"},
{"lineNum":"   67","line":"//! runtime of the program. Logging frameworks will typically include a"},
{"lineNum":"   68","line":"//! function to do this. Any log messages generated before the framework is"},
{"lineNum":"   69","line":"//! initialized will be ignored."},
{"lineNum":"   70","line":"//!"},
{"lineNum":"   71","line":"//! The executable itself may use the `log` crate to log as well."},
{"lineNum":"   72","line":"//!"},
{"lineNum":"   73","line":"//! ### Warning"},
{"lineNum":"   74","line":"//!"},
{"lineNum":"   75","line":"//! The logging system may only be initialized once."},
{"lineNum":"   76","line":"//!"},
{"lineNum":"   77","line":"//! ### Examples"},
{"lineNum":"   78","line":"//!"},
{"lineNum":"   79","line":"//! ```rust,ignore"},
{"lineNum":"   80","line":"//! #[macro_use]"},
{"lineNum":"   81","line":"//! extern crate log;"},
{"lineNum":"   82","line":"//! extern crate my_logger;"},
{"lineNum":"   83","line":"//!"},
{"lineNum":"   84","line":"//! fn main() {"},
{"lineNum":"   85","line":"//!     my_logger::init();"},
{"lineNum":"   86","line":"//!"},
{"lineNum":"   87","line":"//!     info!(\"starting up\");"},
{"lineNum":"   88","line":"//!"},
{"lineNum":"   89","line":"//!     // ..."},
{"lineNum":"   90","line":"//! }"},
{"lineNum":"   91","line":"//! ```"},
{"lineNum":"   92","line":"//!"},
{"lineNum":"   93","line":"//! # Logger implementations"},
{"lineNum":"   94","line":"//!"},
{"lineNum":"   95","line":"//! Loggers implement the `Log` trait. Here\'s a very basic example that simply"},
{"lineNum":"   96","line":"//! logs all messages at the `Error`, `Warn` or `Info` levels to stdout:"},
{"lineNum":"   97","line":"//!"},
{"lineNum":"   98","line":"//! ```rust"},
{"lineNum":"   99","line":"//! extern crate log;"},
{"lineNum":"  100","line":"//!"},
{"lineNum":"  101","line":"//! use log::{LogRecord, LogLevel, LogMetadata};"},
{"lineNum":"  102","line":"//!"},
{"lineNum":"  103","line":"//! struct SimpleLogger;"},
{"lineNum":"  104","line":"//!"},
{"lineNum":"  105","line":"//! impl log::Log for SimpleLogger {"},
{"lineNum":"  106","line":"//!     fn enabled(&self, metadata: &LogMetadata) -> bool {"},
{"lineNum":"  107","line":"//!         metadata.level() <= LogLevel::Info"},
{"lineNum":"  108","line":"//!     }"},
{"lineNum":"  109","line":"//!"},
{"lineNum":"  110","line":"//!     fn log(&self, record: &LogRecord) {"},
{"lineNum":"  111","line":"//!         if self.enabled(record.metadata()) {"},
{"lineNum":"  112","line":"//!             println!(\"{} - {}\", record.level(), record.args());"},
{"lineNum":"  113","line":"//!         }"},
{"lineNum":"  114","line":"//!     }"},
{"lineNum":"  115","line":"//! }"},
{"lineNum":"  116","line":"//!"},
{"lineNum":"  117","line":"//! # fn main() {}"},
{"lineNum":"  118","line":"//! ```"},
{"lineNum":"  119","line":"//!"},
{"lineNum":"  120","line":"//! Loggers are installed by calling the `set_logger` function. It takes a"},
{"lineNum":"  121","line":"//! closure which is provided a `MaxLogLevel` token and returns a `Log` trait"},
{"lineNum":"  122","line":"//! object. The `MaxLogLevel` token controls the global maximum log level. The"},
{"lineNum":"  123","line":"//! logging facade uses this as an optimization to improve performance of log"},
{"lineNum":"  124","line":"//! messages at levels that are disabled. In the case of our example logger,"},
{"lineNum":"  125","line":"//! we\'ll want to set the maximum log level to `Info`, since we ignore any"},
{"lineNum":"  126","line":"//! `Debug` or `Trace` level log messages. A logging framework should provide a"},
{"lineNum":"  127","line":"//! function that wraps a call to `set_logger`, handling initialization of the"},
{"lineNum":"  128","line":"//! logger:"},
{"lineNum":"  129","line":"//!"},
{"lineNum":"  130","line":"//! ```rust"},
{"lineNum":"  131","line":"//! # extern crate log;"},
{"lineNum":"  132","line":"//! # use log::{LogLevel, LogLevelFilter, SetLoggerError, LogMetadata};"},
{"lineNum":"  133","line":"//! # struct SimpleLogger;"},
{"lineNum":"  134","line":"//! # impl log::Log for SimpleLogger {"},
{"lineNum":"  135","line":"//! #   fn enabled(&self, _: &LogMetadata) -> bool { false }"},
{"lineNum":"  136","line":"//! #   fn log(&self, _: &log::LogRecord) {}"},
{"lineNum":"  137","line":"//! # }"},
{"lineNum":"  138","line":"//! # fn main() {}"},
{"lineNum":"  139","line":"//! # #[cfg(feature = \"use_std\")]"},
{"lineNum":"  140","line":"//! pub fn init() -> Result<(), SetLoggerError> {"},
{"lineNum":"  141","line":"//!     log::set_logger(|max_log_level| {"},
{"lineNum":"  142","line":"//!         max_log_level.set(LogLevelFilter::Info);"},
{"lineNum":"  143","line":"//!         Box::new(SimpleLogger)"},
{"lineNum":"  144","line":"//!     })"},
{"lineNum":"  145","line":"//! }"},
{"lineNum":"  146","line":"//! ```"},
{"lineNum":"  147","line":"//!"},
{"lineNum":"  148","line":"//! # Use with `no_std`"},
{"lineNum":"  149","line":"//!"},
{"lineNum":"  150","line":"//! To use the `log` crate without depending on `libstd`, you need to specify"},
{"lineNum":"  151","line":"//! `default-features = false` when specifying the dependency in `Cargo.toml`."},
{"lineNum":"  152","line":"//! This makes no difference to libraries using `log` since the logging API"},
{"lineNum":"  153","line":"//! remains the same. However executables will need to use the `set_logger_raw`"},
{"lineNum":"  154","line":"//! function to initialize a logger and the `shutdown_logger_raw` function to"},
{"lineNum":"  155","line":"//! shut down the global logger before exiting:"},
{"lineNum":"  156","line":"//!"},
{"lineNum":"  157","line":"//! ```rust"},
{"lineNum":"  158","line":"//! # extern crate log;"},
{"lineNum":"  159","line":"//! # use log::{LogLevel, LogLevelFilter, SetLoggerError, ShutdownLoggerError,"},
{"lineNum":"  160","line":"//! #           LogMetadata};"},
{"lineNum":"  161","line":"//! # struct SimpleLogger;"},
{"lineNum":"  162","line":"//! # impl log::Log for SimpleLogger {"},
{"lineNum":"  163","line":"//! #   fn enabled(&self, _: &LogMetadata) -> bool { false }"},
{"lineNum":"  164","line":"//! #   fn log(&self, _: &log::LogRecord) {}"},
{"lineNum":"  165","line":"//! # }"},
{"lineNum":"  166","line":"//! # impl SimpleLogger {"},
{"lineNum":"  167","line":"//! #   fn flush(&self) {}"},
{"lineNum":"  168","line":"//! # }"},
{"lineNum":"  169","line":"//! # fn main() {}"},
{"lineNum":"  170","line":"//! pub fn init() -> Result<(), SetLoggerError> {"},
{"lineNum":"  171","line":"//!     unsafe {"},
{"lineNum":"  172","line":"//!         log::set_logger_raw(|max_log_level| {"},
{"lineNum":"  173","line":"//!             static LOGGER: SimpleLogger = SimpleLogger;"},
{"lineNum":"  174","line":"//!             max_log_level.set(LogLevelFilter::Info);"},
{"lineNum":"  175","line":"//!             &SimpleLogger"},
{"lineNum":"  176","line":"//!         })"},
{"lineNum":"  177","line":"//!     }"},
{"lineNum":"  178","line":"//! }"},
{"lineNum":"  179","line":"//! pub fn shutdown() -> Result<(), ShutdownLoggerError> {"},
{"lineNum":"  180","line":"//!     log::shutdown_logger_raw().map(|logger| {"},
{"lineNum":"  181","line":"//!         let logger = unsafe { &*(logger as *const SimpleLogger) };"},
{"lineNum":"  182","line":"//!         logger.flush();"},
{"lineNum":"  183","line":"//!     })"},
{"lineNum":"  184","line":"//! }"},
{"lineNum":"  185","line":"//! ```"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","},
{"lineNum":"  188","line":"       html_favicon_url = \"https://www.rust-lang.org/favicon.ico\","},
{"lineNum":"  189","line":"       html_root_url = \"https://doc.rust-lang.org/log/\")]"},
{"lineNum":"  190","line":"#![warn(missing_docs)]"},
{"lineNum":"  191","line":"#![cfg_attr(feature = \"nightly\", feature(panic_handler))]"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"#![cfg_attr(not(feature = \"use_std\"), no_std)]"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"#[cfg(not(feature = \"use_std\"))]"},
{"lineNum":"  196","line":"extern crate core as std;"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"#[cfg(feature = \"use_std\")]"},
{"lineNum":"  199","line":"extern crate libc;"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"use std::cmp;"},
{"lineNum":"  202","line":"#[cfg(feature = \"use_std\")]"},
{"lineNum":"  203","line":"use std::error;"},
{"lineNum":"  204","line":"use std::fmt;"},
{"lineNum":"  205","line":"use std::mem;"},
{"lineNum":"  206","line":"use std::ops::Deref;"},
{"lineNum":"  207","line":"use std::str::FromStr;"},
{"lineNum":"  208","line":"use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};"},
{"lineNum":"  209","line":"#[macro_use]"},
{"lineNum":"  210","line":"mod macros;"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"// The setup here is a bit weird to make shutdown_logger_raw work."},
{"lineNum":"  213","line":"//"},
{"lineNum":"  214","line":"// There are four different states that we care about: the logger\'s"},
{"lineNum":"  215","line":"// uninitialized, the logger\'s initializing (set_logger\'s been called but"},
{"lineNum":"  216","line":"// LOGGER hasn\'t actually been set yet), the logger\'s active, or the logger is"},
{"lineNum":"  217","line":"// shut down after calling shutdown_logger_raw."},
{"lineNum":"  218","line":"//"},
{"lineNum":"  219","line":"// The LOGGER static holds a pointer to the global logger. It is protected by"},
{"lineNum":"  220","line":"// the STATE static which determines whether LOGGER has been initialized yet."},
{"lineNum":"  221","line":"//"},
{"lineNum":"  222","line":"// The shutdown_logger_raw routine needs to make sure that no threads are"},
{"lineNum":"  223","line":"// actively logging before it returns. The number of actively logging threads is"},
{"lineNum":"  224","line":"// tracked in the REFCOUNT static. The routine first sets STATE back to"},
{"lineNum":"  225","line":"// INITIALIZING. All logging calls past that point will immediately return"},
{"lineNum":"  226","line":"// without accessing the logger. At that point, the at_exit routine just waits"},
{"lineNum":"  227","line":"// for the refcount to reach 0 before deallocating the logger. Note that the"},
{"lineNum":"  228","line":"// refcount does not necessarily monotonically decrease at this point, as new"},
{"lineNum":"  229","line":"// log calls still increment and decrement it, but the interval in between is"},
{"lineNum":"  230","line":"// small enough that the wait is really just for the active log calls to finish."},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"static mut LOGGER: *const Log = &NopLogger;"},
{"lineNum":"  233","line":"static STATE: AtomicUsize = ATOMIC_USIZE_INIT;"},
{"lineNum":"  234","line":"static REFCOUNT: AtomicUsize = ATOMIC_USIZE_INIT;"},
{"lineNum":"  235","line":""},
{"lineNum":"  236","line":"const UNINITIALIZED: usize = 0;"},
{"lineNum":"  237","line":"const INITIALIZING: usize = 1;"},
{"lineNum":"  238","line":"const INITIALIZED: usize = 2;"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"static MAX_LOG_LEVEL_FILTER: AtomicUsize = ATOMIC_USIZE_INIT;"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"static LOG_LEVEL_NAMES: [&\'static str; 6] = [\"OFF\", \"ERROR\", \"WARN\", \"INFO\","},
{"lineNum":"  243","line":"                                             \"DEBUG\", \"TRACE\"];"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"/// An enum representing the available verbosity levels of the logging framework"},
{"lineNum":"  246","line":"///"},
{"lineNum":"  247","line":"/// A `LogLevel` may be compared directly to a `LogLevelFilter`."},
{"lineNum":"  248","line":"#[repr(usize)]"},
{"lineNum":"  249","line":"#[derive(Copy, Eq, Debug)]"},
{"lineNum":"  250","line":"pub enum LogLevel {"},
{"lineNum":"  251","line":"    /// The \"error\" level."},
{"lineNum":"  252","line":"    ///"},
{"lineNum":"  253","line":"    /// Designates very serious errors."},
{"lineNum":"  254","line":"    Error = 1, // This way these line up with the discriminants for LogLevelFilter below"},
{"lineNum":"  255","line":"    /// The \"warn\" level."},
{"lineNum":"  256","line":"    ///"},
{"lineNum":"  257","line":"    /// Designates hazardous situations."},
{"lineNum":"  258","line":"    Warn,"},
{"lineNum":"  259","line":"    /// The \"info\" level."},
{"lineNum":"  260","line":"    ///"},
{"lineNum":"  261","line":"    /// Designates useful information."},
{"lineNum":"  262","line":"    Info,"},
{"lineNum":"  263","line":"    /// The \"debug\" level."},
{"lineNum":"  264","line":"    ///"},
{"lineNum":"  265","line":"    /// Designates lower priority information."},
{"lineNum":"  266","line":"    Debug,"},
{"lineNum":"  267","line":"    /// The \"trace\" level."},
{"lineNum":"  268","line":"    ///"},
{"lineNum":"  269","line":"    /// Designates very low priority, often extremely verbose, information."},
{"lineNum":"  270","line":"    Trace,"},
{"lineNum":"  271","line":"}"},
{"lineNum":"  272","line":""},
{"lineNum":"  273","line":"impl Clone for LogLevel {"},
{"lineNum":"  274","line":"    #[inline]"},
{"lineNum":"  275","line":"    fn clone(&self) -> LogLevel {"},
{"lineNum":"  276","line":"        *self"},
{"lineNum":"  277","line":"    }"},
{"lineNum":"  278","line":"}"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"impl PartialEq for LogLevel {"},
{"lineNum":"  281","line":"    #[inline]"},
{"lineNum":"  282","line":"    fn eq(&self, other: &LogLevel) -> bool {"},
{"lineNum":"  283","line":"        *self as usize == *other as usize"},
{"lineNum":"  284","line":"    }"},
{"lineNum":"  285","line":"}"},
{"lineNum":"  286","line":""},
{"lineNum":"  287","line":"impl PartialEq<LogLevelFilter> for LogLevel {"},
{"lineNum":"  288","line":"    #[inline]"},
{"lineNum":"  289","line":"    fn eq(&self, other: &LogLevelFilter) -> bool {"},
{"lineNum":"  290","line":"        *self as usize == *other as usize"},
{"lineNum":"  291","line":"    }"},
{"lineNum":"  292","line":"}"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"impl PartialOrd for LogLevel {"},
{"lineNum":"  295","line":"    #[inline]"},
{"lineNum":"  296","line":"    fn partial_cmp(&self, other: &LogLevel) -> Option<cmp::Ordering> {"},
{"lineNum":"  297","line":"        Some(self.cmp(other))"},
{"lineNum":"  298","line":"    }"},
{"lineNum":"  299","line":"}"},
{"lineNum":"  300","line":""},
{"lineNum":"  301","line":"impl PartialOrd<LogLevelFilter> for LogLevel {"},
{"lineNum":"  302","line":"    #[inline]"},
{"lineNum":"  303","line":"    fn partial_cmp(&self, other: &LogLevelFilter) -> Option<cmp::Ordering> {","class":"lineCov","hits":"1","order":"1310",},
{"lineNum":"  304","line":"        Some((*self as usize).cmp(&(*other as usize)))","class":"lineCov","hits":"1","order":"1311",},
{"lineNum":"  305","line":"    }"},
{"lineNum":"  306","line":"}"},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"impl Ord for LogLevel {"},
{"lineNum":"  309","line":"    #[inline]"},
{"lineNum":"  310","line":"    fn cmp(&self, other: &LogLevel) -> cmp::Ordering {"},
{"lineNum":"  311","line":"        (*self as usize).cmp(&(*other as usize))"},
{"lineNum":"  312","line":"    }"},
{"lineNum":"  313","line":"}"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"fn ok_or<T, E>(t: Option<T>, e: E) -> Result<T, E> {"},
{"lineNum":"  316","line":"    match t {"},
{"lineNum":"  317","line":"        Some(t) => Ok(t),"},
{"lineNum":"  318","line":"        None => Err(e),"},
{"lineNum":"  319","line":"    }"},
{"lineNum":"  320","line":"}"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"// Reimplemented here because std::ascii is not available in libcore"},
{"lineNum":"  323","line":"fn eq_ignore_ascii_case(a: &str, b: &str) -> bool {"},
{"lineNum":"  324","line":"    fn to_ascii_uppercase(c: u8) -> u8 {"},
{"lineNum":"  325","line":"        if c >= b\'a\' && c <= b\'z\' {"},
{"lineNum":"  326","line":"            c - b\'a\' + b\'A\'"},
{"lineNum":"  327","line":"        } else {"},
{"lineNum":"  328","line":"            c"},
{"lineNum":"  329","line":"        }"},
{"lineNum":"  330","line":"    }"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"    if a.len() == b.len() {"},
{"lineNum":"  333","line":"        a.bytes()"},
{"lineNum":"  334","line":"         .zip(b.bytes())"},
{"lineNum":"  335","line":"         .all(|(a, b)| to_ascii_uppercase(a) == to_ascii_uppercase(b))"},
{"lineNum":"  336","line":"    } else {"},
{"lineNum":"  337","line":"        false"},
{"lineNum":"  338","line":"    }"},
{"lineNum":"  339","line":"}"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"impl FromStr for LogLevel {"},
{"lineNum":"  342","line":"    type Err = ();"},
{"lineNum":"  343","line":"    fn from_str(level: &str) -> Result<LogLevel, ()> {"},
{"lineNum":"  344","line":"        ok_or(LOG_LEVEL_NAMES.iter()"},
{"lineNum":"  345","line":"                    .position(|&name| eq_ignore_ascii_case(name, level))"},
{"lineNum":"  346","line":"                    .into_iter()"},
{"lineNum":"  347","line":"                    .filter(|&idx| idx != 0)"},
{"lineNum":"  348","line":"                    .map(|idx| LogLevel::from_usize(idx).unwrap())"},
{"lineNum":"  349","line":"                    .next(), ())"},
{"lineNum":"  350","line":"    }"},
{"lineNum":"  351","line":"}"},
{"lineNum":"  352","line":""},
{"lineNum":"  353","line":"impl fmt::Display for LogLevel {"},
{"lineNum":"  354","line":"    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  355","line":"        fmt.pad(LOG_LEVEL_NAMES[*self as usize])"},
{"lineNum":"  356","line":"    }"},
{"lineNum":"  357","line":"}"},
{"lineNum":"  358","line":""},
{"lineNum":"  359","line":"impl LogLevel {"},
{"lineNum":"  360","line":"    fn from_usize(u: usize) -> Option<LogLevel> {"},
{"lineNum":"  361","line":"        match u {"},
{"lineNum":"  362","line":"            1 => Some(LogLevel::Error),"},
{"lineNum":"  363","line":"            2 => Some(LogLevel::Warn),"},
{"lineNum":"  364","line":"            3 => Some(LogLevel::Info),"},
{"lineNum":"  365","line":"            4 => Some(LogLevel::Debug),"},
{"lineNum":"  366","line":"            5 => Some(LogLevel::Trace),"},
{"lineNum":"  367","line":"            _ => None"},
{"lineNum":"  368","line":"        }"},
{"lineNum":"  369","line":"    }"},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":"    /// Returns the most verbose logging level."},
{"lineNum":"  372","line":"    #[inline]"},
{"lineNum":"  373","line":"    pub fn max() -> LogLevel {"},
{"lineNum":"  374","line":"        LogLevel::Trace"},
{"lineNum":"  375","line":"    }"},
{"lineNum":"  376","line":""},
{"lineNum":"  377","line":"    /// Converts the `LogLevel` to the equivalent `LogLevelFilter`."},
{"lineNum":"  378","line":"    #[inline]"},
{"lineNum":"  379","line":"    pub fn to_log_level_filter(&self) -> LogLevelFilter {"},
{"lineNum":"  380","line":"        LogLevelFilter::from_usize(*self as usize).unwrap()"},
{"lineNum":"  381","line":"    }"},
{"lineNum":"  382","line":"}"},
{"lineNum":"  383","line":""},
{"lineNum":"  384","line":"/// An enum representing the available verbosity level filters of the logging"},
{"lineNum":"  385","line":"/// framework."},
{"lineNum":"  386","line":"///"},
{"lineNum":"  387","line":"/// A `LogLevelFilter` may be compared directly to a `LogLevel`."},
{"lineNum":"  388","line":"#[repr(usize)]"},
{"lineNum":"  389","line":"#[derive(Copy, Eq, Debug)]"},
{"lineNum":"  390","line":"pub enum LogLevelFilter {"},
{"lineNum":"  391","line":"    /// A level lower than all log levels."},
{"lineNum":"  392","line":"    Off,"},
{"lineNum":"  393","line":"    /// Corresponds to the `Error` log level."},
{"lineNum":"  394","line":"    Error,"},
{"lineNum":"  395","line":"    /// Corresponds to the `Warn` log level."},
{"lineNum":"  396","line":"    Warn,"},
{"lineNum":"  397","line":"    /// Corresponds to the `Info` log level."},
{"lineNum":"  398","line":"    Info,"},
{"lineNum":"  399","line":"    /// Corresponds to the `Debug` log level."},
{"lineNum":"  400","line":"    Debug,"},
{"lineNum":"  401","line":"    /// Corresponds to the `Trace` log level."},
{"lineNum":"  402","line":"    Trace,"},
{"lineNum":"  403","line":"}"},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":"// Deriving generates terrible impls of these traits"},
{"lineNum":"  406","line":""},
{"lineNum":"  407","line":"impl Clone for LogLevelFilter {"},
{"lineNum":"  408","line":"    #[inline]"},
{"lineNum":"  409","line":"    fn clone(&self) -> LogLevelFilter {"},
{"lineNum":"  410","line":"        *self"},
{"lineNum":"  411","line":"    }"},
{"lineNum":"  412","line":"}"},
{"lineNum":"  413","line":""},
{"lineNum":"  414","line":"impl PartialEq for LogLevelFilter {"},
{"lineNum":"  415","line":"    #[inline]"},
{"lineNum":"  416","line":"    fn eq(&self, other: &LogLevelFilter) -> bool {"},
{"lineNum":"  417","line":"        *self as usize == *other as usize"},
{"lineNum":"  418","line":"    }"},
{"lineNum":"  419","line":"}"},
{"lineNum":"  420","line":""},
{"lineNum":"  421","line":"impl PartialEq<LogLevel> for LogLevelFilter {"},
{"lineNum":"  422","line":"    #[inline]"},
{"lineNum":"  423","line":"    fn eq(&self, other: &LogLevel) -> bool {"},
{"lineNum":"  424","line":"        other.eq(self)"},
{"lineNum":"  425","line":"    }"},
{"lineNum":"  426","line":"}"},
{"lineNum":"  427","line":""},
{"lineNum":"  428","line":"impl PartialOrd for LogLevelFilter {"},
{"lineNum":"  429","line":"    #[inline]"},
{"lineNum":"  430","line":"    fn partial_cmp(&self, other: &LogLevelFilter) -> Option<cmp::Ordering> {"},
{"lineNum":"  431","line":"        Some(self.cmp(other))"},
{"lineNum":"  432","line":"    }"},
{"lineNum":"  433","line":"}"},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"impl PartialOrd<LogLevel> for LogLevelFilter {"},
{"lineNum":"  436","line":"    #[inline]"},
{"lineNum":"  437","line":"    fn partial_cmp(&self, other: &LogLevel) -> Option<cmp::Ordering> {"},
{"lineNum":"  438","line":"        other.partial_cmp(self).map(|x| x.reverse())"},
{"lineNum":"  439","line":"    }"},
{"lineNum":"  440","line":"}"},
{"lineNum":"  441","line":""},
{"lineNum":"  442","line":"impl Ord for LogLevelFilter {"},
{"lineNum":"  443","line":"    #[inline]"},
{"lineNum":"  444","line":"    fn cmp(&self, other: &LogLevelFilter) -> cmp::Ordering {"},
{"lineNum":"  445","line":"        (*self as usize).cmp(&(*other as usize))"},
{"lineNum":"  446","line":"    }"},
{"lineNum":"  447","line":"}"},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"impl FromStr for LogLevelFilter {"},
{"lineNum":"  450","line":"    type Err = ();"},
{"lineNum":"  451","line":"    fn from_str(level: &str) -> Result<LogLevelFilter, ()> {"},
{"lineNum":"  452","line":"        ok_or(LOG_LEVEL_NAMES.iter()"},
{"lineNum":"  453","line":"                    .position(|&name| eq_ignore_ascii_case(name, level))"},
{"lineNum":"  454","line":"                    .map(|p| LogLevelFilter::from_usize(p).unwrap()), ())"},
{"lineNum":"  455","line":"    }"},
{"lineNum":"  456","line":"}"},
{"lineNum":"  457","line":""},
{"lineNum":"  458","line":"impl fmt::Display for LogLevelFilter {"},
{"lineNum":"  459","line":"    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  460","line":"        write!(fmt, \"{}\", LOG_LEVEL_NAMES[*self as usize])"},
{"lineNum":"  461","line":"    }"},
{"lineNum":"  462","line":"}"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"impl LogLevelFilter {"},
{"lineNum":"  465","line":"    fn from_usize(u: usize) -> Option<LogLevelFilter> {"},
{"lineNum":"  466","line":"        match u {"},
{"lineNum":"  467","line":"            0 => Some(LogLevelFilter::Off),"},
{"lineNum":"  468","line":"            1 => Some(LogLevelFilter::Error),"},
{"lineNum":"  469","line":"            2 => Some(LogLevelFilter::Warn),"},
{"lineNum":"  470","line":"            3 => Some(LogLevelFilter::Info),"},
{"lineNum":"  471","line":"            4 => Some(LogLevelFilter::Debug),"},
{"lineNum":"  472","line":"            5 => Some(LogLevelFilter::Trace),"},
{"lineNum":"  473","line":"            _ => None"},
{"lineNum":"  474","line":"        }"},
{"lineNum":"  475","line":"    }"},
{"lineNum":"  476","line":"    /// Returns the most verbose logging level filter."},
{"lineNum":"  477","line":"    #[inline]"},
{"lineNum":"  478","line":"    pub fn max() -> LogLevelFilter {"},
{"lineNum":"  479","line":"        LogLevelFilter::Trace"},
{"lineNum":"  480","line":"    }"},
{"lineNum":"  481","line":""},
{"lineNum":"  482","line":"    /// Converts `self` to the equivalent `LogLevel`."},
{"lineNum":"  483","line":"    ///"},
{"lineNum":"  484","line":"    /// Returns `None` if `self` is `LogLevelFilter::Off`."},
{"lineNum":"  485","line":"    #[inline]"},
{"lineNum":"  486","line":"    pub fn to_log_level(&self) -> Option<LogLevel> {"},
{"lineNum":"  487","line":"        LogLevel::from_usize(*self as usize)"},
{"lineNum":"  488","line":"    }"},
{"lineNum":"  489","line":"}"},
{"lineNum":"  490","line":""},
{"lineNum":"  491","line":"/// The \"payload\" of a log message."},
{"lineNum":"  492","line":"pub struct LogRecord<\'a> {"},
{"lineNum":"  493","line":"    metadata: LogMetadata<\'a>,"},
{"lineNum":"  494","line":"    location: &\'a LogLocation,"},
{"lineNum":"  495","line":"    args: fmt::Arguments<\'a>,"},
{"lineNum":"  496","line":"}"},
{"lineNum":"  497","line":""},
{"lineNum":"  498","line":"impl<\'a> LogRecord<\'a> {"},
{"lineNum":"  499","line":"    /// The message body."},
{"lineNum":"  500","line":"    pub fn args(&self) -> &fmt::Arguments<\'a> {"},
{"lineNum":"  501","line":"        &self.args"},
{"lineNum":"  502","line":"    }"},
{"lineNum":"  503","line":""},
{"lineNum":"  504","line":"    /// Metadata about the log directive."},
{"lineNum":"  505","line":"    pub fn metadata(&self) -> &LogMetadata {"},
{"lineNum":"  506","line":"        &self.metadata"},
{"lineNum":"  507","line":"    }"},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"    /// The location of the log directive."},
{"lineNum":"  510","line":"    pub fn location(&self) -> &LogLocation {"},
{"lineNum":"  511","line":"        self.location"},
{"lineNum":"  512","line":"    }"},
{"lineNum":"  513","line":""},
{"lineNum":"  514","line":"    /// The verbosity level of the message."},
{"lineNum":"  515","line":"    pub fn level(&self) -> LogLevel {"},
{"lineNum":"  516","line":"        self.metadata.level()"},
{"lineNum":"  517","line":"    }"},
{"lineNum":"  518","line":""},
{"lineNum":"  519","line":"    /// The name of the target of the directive."},
{"lineNum":"  520","line":"    pub fn target(&self) -> &str {"},
{"lineNum":"  521","line":"        self.metadata.target()"},
{"lineNum":"  522","line":"    }"},
{"lineNum":"  523","line":"}"},
{"lineNum":"  524","line":""},
{"lineNum":"  525","line":"/// Metadata about a log message."},
{"lineNum":"  526","line":"pub struct LogMetadata<\'a> {"},
{"lineNum":"  527","line":"    level: LogLevel,"},
{"lineNum":"  528","line":"    target: &\'a str,"},
{"lineNum":"  529","line":"}"},
{"lineNum":"  530","line":""},
{"lineNum":"  531","line":"impl<\'a> LogMetadata<\'a> {"},
{"lineNum":"  532","line":"    /// The verbosity level of the message."},
{"lineNum":"  533","line":"    pub fn level(&self) -> LogLevel {"},
{"lineNum":"  534","line":"        self.level"},
{"lineNum":"  535","line":"    }"},
{"lineNum":"  536","line":""},
{"lineNum":"  537","line":"    /// The name of the target of the directive."},
{"lineNum":"  538","line":"    pub fn target(&self) -> &str {"},
{"lineNum":"  539","line":"        self.target"},
{"lineNum":"  540","line":"    }"},
{"lineNum":"  541","line":"}"},
{"lineNum":"  542","line":""},
{"lineNum":"  543","line":"/// A trait encapsulating the operations required of a logger"},
{"lineNum":"  544","line":"pub trait Log: Sync+Send {"},
{"lineNum":"  545","line":"    /// Determines if a log message with the specified metadata would be"},
{"lineNum":"  546","line":"    /// logged."},
{"lineNum":"  547","line":"    ///"},
{"lineNum":"  548","line":"    /// This is used by the `log_enabled!` macro to allow callers to avoid"},
{"lineNum":"  549","line":"    /// expensive computation of log message arguments if the message would be"},
{"lineNum":"  550","line":"    /// discarded anyway."},
{"lineNum":"  551","line":"    fn enabled(&self, metadata: &LogMetadata) -> bool;"},
{"lineNum":"  552","line":""},
{"lineNum":"  553","line":"    /// Logs the `LogRecord`."},
{"lineNum":"  554","line":"    ///"},
{"lineNum":"  555","line":"    /// Note that `enabled` is *not* necessarily called before this method."},
{"lineNum":"  556","line":"    /// Implementations of `log` should perform all necessary filtering"},
{"lineNum":"  557","line":"    /// internally."},
{"lineNum":"  558","line":"    fn log(&self, record: &LogRecord);"},
{"lineNum":"  559","line":"}"},
{"lineNum":"  560","line":""},
{"lineNum":"  561","line":"// Just used as a dummy initial value for LOGGER"},
{"lineNum":"  562","line":"struct NopLogger;"},
{"lineNum":"  563","line":""},
{"lineNum":"  564","line":"impl Log for NopLogger {"},
{"lineNum":"  565","line":"    fn enabled(&self, _: &LogMetadata) -> bool { false }","class":"lineNoCov","hits":"0",},
{"lineNum":"  566","line":""},
{"lineNum":"  567","line":"    fn log(&self, _: &LogRecord) {}","class":"lineNoCov","hits":"0",},
{"lineNum":"  568","line":"}"},
{"lineNum":"  569","line":""},
{"lineNum":"  570","line":"/// The location of a log message."},
{"lineNum":"  571","line":"///"},
{"lineNum":"  572","line":"/// # Warning"},
{"lineNum":"  573","line":"///"},
{"lineNum":"  574","line":"/// The fields of this struct are public so that they may be initialized by the"},
{"lineNum":"  575","line":"/// `log!` macro. They are subject to change at any time and should never be"},
{"lineNum":"  576","line":"/// accessed directly."},
{"lineNum":"  577","line":"#[derive(Copy, Clone, Debug)]"},
{"lineNum":"  578","line":"pub struct LogLocation {"},
{"lineNum":"  579","line":"    #[doc(hidden)]"},
{"lineNum":"  580","line":"    pub __module_path: &\'static str,"},
{"lineNum":"  581","line":"    #[doc(hidden)]"},
{"lineNum":"  582","line":"    pub __file: &\'static str,"},
{"lineNum":"  583","line":"    #[doc(hidden)]"},
{"lineNum":"  584","line":"    pub __line: u32,"},
{"lineNum":"  585","line":"}"},
{"lineNum":"  586","line":""},
{"lineNum":"  587","line":"impl LogLocation {"},
{"lineNum":"  588","line":"    /// The module path of the message."},
{"lineNum":"  589","line":"    pub fn module_path(&self) -> &str {"},
{"lineNum":"  590","line":"        self.__module_path"},
{"lineNum":"  591","line":"    }"},
{"lineNum":"  592","line":""},
{"lineNum":"  593","line":"    /// The source file containing the message."},
{"lineNum":"  594","line":"    pub fn file(&self) -> &str {"},
{"lineNum":"  595","line":"        self.__file"},
{"lineNum":"  596","line":"    }"},
{"lineNum":"  597","line":""},
{"lineNum":"  598","line":"    /// The line containing the message."},
{"lineNum":"  599","line":"    pub fn line(&self) -> u32 {"},
{"lineNum":"  600","line":"        self.__line"},
{"lineNum":"  601","line":"    }"},
{"lineNum":"  602","line":"}"},
{"lineNum":"  603","line":""},
{"lineNum":"  604","line":"/// A token providing read and write access to the global maximum log level"},
{"lineNum":"  605","line":"/// filter."},
{"lineNum":"  606","line":"///"},
{"lineNum":"  607","line":"/// The maximum log level is used as an optimization to avoid evaluating log"},
{"lineNum":"  608","line":"/// messages that will be ignored by the logger. Any message with a level"},
{"lineNum":"  609","line":"/// higher than the maximum log level filter will be ignored. A logger should"},
{"lineNum":"  610","line":"/// make sure to keep the maximum log level filter in sync with its current"},
{"lineNum":"  611","line":"/// configuration."},
{"lineNum":"  612","line":"#[allow(missing_copy_implementations)]"},
{"lineNum":"  613","line":"pub struct MaxLogLevelFilter(());"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"impl fmt::Debug for MaxLogLevelFilter {"},
{"lineNum":"  616","line":"    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  617","line":"        write!(fmt, \"MaxLogLevelFilter\")"},
{"lineNum":"  618","line":"    }"},
{"lineNum":"  619","line":"}"},
{"lineNum":"  620","line":""},
{"lineNum":"  621","line":"impl MaxLogLevelFilter {"},
{"lineNum":"  622","line":"    /// Gets the current maximum log level filter."},
{"lineNum":"  623","line":"    pub fn get(&self) -> LogLevelFilter {"},
{"lineNum":"  624","line":"        max_log_level()"},
{"lineNum":"  625","line":"    }"},
{"lineNum":"  626","line":""},
{"lineNum":"  627","line":"    /// Sets the maximum log level."},
{"lineNum":"  628","line":"    pub fn set(&self, level: LogLevelFilter) {"},
{"lineNum":"  629","line":"        MAX_LOG_LEVEL_FILTER.store(level as usize, Ordering::SeqCst)"},
{"lineNum":"  630","line":"    }"},
{"lineNum":"  631","line":"}"},
{"lineNum":"  632","line":""},
{"lineNum":"  633","line":"/// Returns the current maximum log level."},
{"lineNum":"  634","line":"///"},
{"lineNum":"  635","line":"/// The `log!`, `error!`, `warn!`, `info!`, `debug!`, and `trace!` macros check"},
{"lineNum":"  636","line":"/// this value and discard any message logged at a higher level. The maximum"},
{"lineNum":"  637","line":"/// log level is set by the `MaxLogLevel` token passed to loggers."},
{"lineNum":"  638","line":"#[inline(always)]"},
{"lineNum":"  639","line":"pub fn max_log_level() -> LogLevelFilter {"},
{"lineNum":"  640","line":"    unsafe { mem::transmute(MAX_LOG_LEVEL_FILTER.load(Ordering::Relaxed)) }","class":"lineCov","hits":"1","order":"1312",},
{"lineNum":"  641","line":"}"},
{"lineNum":"  642","line":""},
{"lineNum":"  643","line":"/// Sets the global logger."},
{"lineNum":"  644","line":"///"},
{"lineNum":"  645","line":"/// The `make_logger` closure is passed a `MaxLogLevel` object, which the"},
{"lineNum":"  646","line":"/// logger should use to keep the global maximum log level in sync with the"},
{"lineNum":"  647","line":"/// highest log level that the logger will not ignore."},
{"lineNum":"  648","line":"///"},
{"lineNum":"  649","line":"/// This function may only be called once in the lifetime of a program. Any log"},
{"lineNum":"  650","line":"/// events that occur before the call to `set_logger` completes will be"},
{"lineNum":"  651","line":"/// ignored."},
{"lineNum":"  652","line":"///"},
{"lineNum":"  653","line":"/// This function does not typically need to be called manually. Logger"},
{"lineNum":"  654","line":"/// implementations should provide an initialization method that calls"},
{"lineNum":"  655","line":"/// `set_logger` internally."},
{"lineNum":"  656","line":"///"},
{"lineNum":"  657","line":"/// Requires the `use_std` feature (enabled by default)."},
{"lineNum":"  658","line":"#[cfg(feature = \"use_std\")]"},
{"lineNum":"  659","line":"pub fn set_logger<M>(make_logger: M) -> Result<(), SetLoggerError>"},
{"lineNum":"  660","line":"        where M: FnOnce(MaxLogLevelFilter) -> Box<Log> {"},
{"lineNum":"  661","line":"    let result = unsafe {"},
{"lineNum":"  662","line":"        set_logger_raw(|max_level| mem::transmute(make_logger(max_level)))"},
{"lineNum":"  663","line":"    };"},
{"lineNum":"  664","line":""},
{"lineNum":"  665","line":"    return match result {"},
{"lineNum":"  666","line":"        Ok(()) => {"},
{"lineNum":"  667","line":"            assert_eq!(unsafe { libc::atexit(shutdown) }, 0);"},
{"lineNum":"  668","line":"            Ok(())"},
{"lineNum":"  669","line":"        }"},
{"lineNum":"  670","line":"        Err(_) => Err(SetLoggerError(())),"},
{"lineNum":"  671","line":"    };"},
{"lineNum":"  672","line":""},
{"lineNum":"  673","line":"    extern fn shutdown() {"},
{"lineNum":"  674","line":"        shutdown_logger_raw().map(|logger| unsafe {"},
{"lineNum":"  675","line":"            mem::transmute::<_, Box<Log>>(logger);"},
{"lineNum":"  676","line":"        }).ok();"},
{"lineNum":"  677","line":"    }"},
{"lineNum":"  678","line":"}"},
{"lineNum":"  679","line":""},
{"lineNum":"  680","line":"/// Sets the global logger from a raw pointer."},
{"lineNum":"  681","line":"///"},
{"lineNum":"  682","line":"/// This function is similar to `set_logger` except that it is usable in"},
{"lineNum":"  683","line":"/// `no_std` code. Another difference is that the logger is not automatically"},
{"lineNum":"  684","line":"/// shut down on program exit, and `shutdown_logger_raw` must be called to"},
{"lineNum":"  685","line":"/// manually shut it down."},
{"lineNum":"  686","line":"///"},
{"lineNum":"  687","line":"/// The `make_logger` closure is passed a `MaxLogLevel` object, which the"},
{"lineNum":"  688","line":"/// logger should use to keep the global maximum log level in sync with the"},
{"lineNum":"  689","line":"/// highest log level that the logger will not ignore."},
{"lineNum":"  690","line":"///"},
{"lineNum":"  691","line":"/// This function may only be called once in the lifetime of a program. Any log"},
{"lineNum":"  692","line":"/// events that occur before the call to `set_logger_raw` completes will be"},
{"lineNum":"  693","line":"/// ignored."},
{"lineNum":"  694","line":"///"},
{"lineNum":"  695","line":"/// This function does not typically need to be called manually. Logger"},
{"lineNum":"  696","line":"/// implementations should provide an initialization method that calls"},
{"lineNum":"  697","line":"/// `set_logger_raw` internally."},
{"lineNum":"  698","line":"///"},
{"lineNum":"  699","line":"/// # Safety"},
{"lineNum":"  700","line":"///"},
{"lineNum":"  701","line":"/// The pointer returned by `make_logger` must remain valid for the entire"},
{"lineNum":"  702","line":"/// duration of the program or until `shutdown_logger_raw` is called."},
{"lineNum":"  703","line":"pub unsafe fn set_logger_raw<M>(make_logger: M) -> Result<(), SetLoggerError>"},
{"lineNum":"  704","line":"        where M: FnOnce(MaxLogLevelFilter) -> *const Log {"},
{"lineNum":"  705","line":"    if STATE.compare_and_swap(UNINITIALIZED, INITIALIZING,"},
{"lineNum":"  706","line":"                              Ordering::SeqCst) != UNINITIALIZED {"},
{"lineNum":"  707","line":"        return Err(SetLoggerError(()));"},
{"lineNum":"  708","line":"    }"},
{"lineNum":"  709","line":""},
{"lineNum":"  710","line":"    LOGGER = make_logger(MaxLogLevelFilter(()));"},
{"lineNum":"  711","line":"    STATE.store(INITIALIZED, Ordering::SeqCst);"},
{"lineNum":"  712","line":"    Ok(())"},
{"lineNum":"  713","line":"}"},
{"lineNum":"  714","line":""},
{"lineNum":"  715","line":"/// Shuts down the global logger."},
{"lineNum":"  716","line":"///"},
{"lineNum":"  717","line":"/// This function may only be called once in the lifetime of a program, and may"},
{"lineNum":"  718","line":"/// not be called before `set_logger_raw`. Once the global logger has been shut"},
{"lineNum":"  719","line":"/// down, it can no longer be re-initialized by `set_logger_raw`. Any log"},
{"lineNum":"  720","line":"/// events that occur after the call to `shutdown_logger_raw` completes will be"},
{"lineNum":"  721","line":"/// ignored."},
{"lineNum":"  722","line":"///"},
{"lineNum":"  723","line":"/// The pointer that was originally passed to `set_logger_raw` is returned on"},
{"lineNum":"  724","line":"/// success. At that point it is guaranteed that no other threads are"},
{"lineNum":"  725","line":"/// concurrently accessing the logger object."},
{"lineNum":"  726","line":"///"},
{"lineNum":"  727","line":"/// This function should not be called when the global logger was registered"},
{"lineNum":"  728","line":"/// using `set_logger`, since in that case the logger will automatically be shut"},
{"lineNum":"  729","line":"/// down when the program exits"},
{"lineNum":"  730","line":"pub fn shutdown_logger_raw() -> Result<*const Log, ShutdownLoggerError> {"},
{"lineNum":"  731","line":"    // Set the global log level to stop other thread from logging"},
{"lineNum":"  732","line":"    MAX_LOG_LEVEL_FILTER.store(0, Ordering::SeqCst);"},
{"lineNum":"  733","line":""},
{"lineNum":"  734","line":"    // Set to INITIALIZING to prevent re-initialization after"},
{"lineNum":"  735","line":"    if STATE.compare_and_swap(INITIALIZED, INITIALIZING,"},
{"lineNum":"  736","line":"                              Ordering::SeqCst) != INITIALIZED {"},
{"lineNum":"  737","line":"        return Err(ShutdownLoggerError(()));"},
{"lineNum":"  738","line":"    }"},
{"lineNum":"  739","line":""},
{"lineNum":"  740","line":"    while REFCOUNT.load(Ordering::SeqCst) != 0 {"},
{"lineNum":"  741","line":"        // FIXME add a sleep here when it doesn\'t involve timers"},
{"lineNum":"  742","line":"    }"},
{"lineNum":"  743","line":""},
{"lineNum":"  744","line":"    unsafe {"},
{"lineNum":"  745","line":"        let logger = LOGGER;"},
{"lineNum":"  746","line":"        LOGGER = &NopLogger;"},
{"lineNum":"  747","line":"        Ok(logger)"},
{"lineNum":"  748","line":"    }"},
{"lineNum":"  749","line":"}"},
{"lineNum":"  750","line":""},
{"lineNum":"  751","line":"/// The type returned by `set_logger` if `set_logger` has already been called."},
{"lineNum":"  752","line":"#[allow(missing_copy_implementations)]"},
{"lineNum":"  753","line":"#[derive(Debug)]"},
{"lineNum":"  754","line":"pub struct SetLoggerError(());"},
{"lineNum":"  755","line":""},
{"lineNum":"  756","line":"impl fmt::Display for SetLoggerError {"},
{"lineNum":"  757","line":"    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  758","line":"        write!(fmt, \"attempted to set a logger after the logging system \\"},
{"lineNum":"  759","line":"                     was already initialized\")"},
{"lineNum":"  760","line":"    }"},
{"lineNum":"  761","line":"}"},
{"lineNum":"  762","line":""},
{"lineNum":"  763","line":"// The Error trait is not available in libcore"},
{"lineNum":"  764","line":"#[cfg(feature = \"use_std\")]"},
{"lineNum":"  765","line":"impl error::Error for SetLoggerError {"},
{"lineNum":"  766","line":"    fn description(&self) -> &str { \"set_logger() called multiple times\" }"},
{"lineNum":"  767","line":"}"},
{"lineNum":"  768","line":""},
{"lineNum":"  769","line":"/// The type returned by `shutdown_logger_raw` if `shutdown_logger_raw` has"},
{"lineNum":"  770","line":"/// already been called or if `set_logger_raw` has not been called yet."},
{"lineNum":"  771","line":"#[allow(missing_copy_implementations)]"},
{"lineNum":"  772","line":"#[derive(Debug)]"},
{"lineNum":"  773","line":"pub struct ShutdownLoggerError(());"},
{"lineNum":"  774","line":""},
{"lineNum":"  775","line":"impl fmt::Display for ShutdownLoggerError {"},
{"lineNum":"  776","line":"    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  777","line":"        write!(fmt, \"attempted to shut down a logger without an active logger\")"},
{"lineNum":"  778","line":"    }"},
{"lineNum":"  779","line":"}"},
{"lineNum":"  780","line":""},
{"lineNum":"  781","line":"// The Error trait is not available in libcore"},
{"lineNum":"  782","line":"#[cfg(feature = \"use_std\")]"},
{"lineNum":"  783","line":"impl error::Error for ShutdownLoggerError {"},
{"lineNum":"  784","line":"    fn description(&self) -> &str { \"shutdown_logger_raw() called without an active logger\" }"},
{"lineNum":"  785","line":"}"},
{"lineNum":"  786","line":""},
{"lineNum":"  787","line":"/// Registers a panic handler which logs at the error level."},
{"lineNum":"  788","line":"///"},
{"lineNum":"  789","line":"/// The format is the same as the default panic handler. The reporting module is"},
{"lineNum":"  790","line":"/// `log::panic`."},
{"lineNum":"  791","line":"///"},
{"lineNum":"  792","line":"/// Requires the `use_std` (enabled by default) and `nightly` features."},
{"lineNum":"  793","line":"#[cfg(all(feature = \"nightly\", feature = \"use_std\"))]"},
{"lineNum":"  794","line":"pub fn log_panics() {"},
{"lineNum":"  795","line":"    std::panic::set_handler(panic::log);"},
{"lineNum":"  796","line":"}"},
{"lineNum":"  797","line":""},
{"lineNum":"  798","line":"// inner module so that the reporting module is log::panic instead of log"},
{"lineNum":"  799","line":"#[cfg(all(feature = \"nightly\", feature = \"use_std\"))]"},
{"lineNum":"  800","line":"mod panic {"},
{"lineNum":"  801","line":"    use std::panic::PanicInfo;"},
{"lineNum":"  802","line":"    use std::thread;"},
{"lineNum":"  803","line":""},
{"lineNum":"  804","line":"    pub fn log(info: &PanicInfo) {"},
{"lineNum":"  805","line":"        let thread = thread::current();"},
{"lineNum":"  806","line":"        let thread = thread.name().unwrap_or(\"<unnamed>\");"},
{"lineNum":"  807","line":""},
{"lineNum":"  808","line":"        let msg = match info.payload().downcast_ref::<&\'static str>() {"},
{"lineNum":"  809","line":"            Some(s) => *s,"},
{"lineNum":"  810","line":"            None => match info.payload().downcast_ref::<String>() {"},
{"lineNum":"  811","line":"                Some(s) => &s[..],"},
{"lineNum":"  812","line":"                None => \"Box<Any>\","},
{"lineNum":"  813","line":"            }"},
{"lineNum":"  814","line":"        };"},
{"lineNum":"  815","line":""},
{"lineNum":"  816","line":"        match info.location() {"},
{"lineNum":"  817","line":"            Some(location) => {"},
{"lineNum":"  818","line":"                error!(\"thread \'{}\' panicked at \'{}\': {}:{}\","},
{"lineNum":"  819","line":"                       thread,"},
{"lineNum":"  820","line":"                       msg,"},
{"lineNum":"  821","line":"                       location.file(),"},
{"lineNum":"  822","line":"                       location.line())"},
{"lineNum":"  823","line":"            }"},
{"lineNum":"  824","line":"            None => error!(\"thread \'{}\' panicked at \'{}\'\", thread, msg),"},
{"lineNum":"  825","line":"        }"},
{"lineNum":"  826","line":"    }"},
{"lineNum":"  827","line":"}"},
{"lineNum":"  828","line":""},
{"lineNum":"  829","line":"struct LoggerGuard(&\'static Log);"},
{"lineNum":"  830","line":""},
{"lineNum":"  831","line":"impl Drop for LoggerGuard {"},
{"lineNum":"  832","line":"    fn drop(&mut self) {","class":"lineNoCov","hits":"0",},
{"lineNum":"  833","line":"        REFCOUNT.fetch_sub(1, Ordering::SeqCst);","class":"lineNoCov","hits":"0",},
{"lineNum":"  834","line":"    }","class":"lineNoCov","hits":"0",},
{"lineNum":"  835","line":"}"},
{"lineNum":"  836","line":""},
{"lineNum":"  837","line":"impl Deref for LoggerGuard {"},
{"lineNum":"  838","line":"    type Target = Log;"},
{"lineNum":"  839","line":""},
{"lineNum":"  840","line":"    fn deref(&self) -> &(Log + \'static) {","class":"lineNoCov","hits":"0",},
{"lineNum":"  841","line":"        self.0"},
{"lineNum":"  842","line":"    }","class":"lineNoCov","hits":"0",},
{"lineNum":"  843","line":"}"},
{"lineNum":"  844","line":""},
{"lineNum":"  845","line":"fn logger() -> Option<LoggerGuard> {","class":"lineNoCov","hits":"0",},
{"lineNum":"  846","line":"    REFCOUNT.fetch_add(1, Ordering::SeqCst);","class":"lineNoCov","hits":"0",},
{"lineNum":"  847","line":"    if STATE.load(Ordering::SeqCst) != INITIALIZED {","class":"lineNoCov","hits":"0",},
{"lineNum":"  848","line":"        REFCOUNT.fetch_sub(1, Ordering::SeqCst);","class":"lineNoCov","hits":"0",},
{"lineNum":"  849","line":"        None"},
{"lineNum":"  850","line":"    } else {"},
{"lineNum":"  851","line":"        Some(LoggerGuard(unsafe { &*LOGGER }))"},
{"lineNum":"  852","line":"    }"},
{"lineNum":"  853","line":"}","class":"lineNoCov","hits":"0",},
{"lineNum":"  854","line":""},
{"lineNum":"  855","line":"// WARNING"},
{"lineNum":"  856","line":"// This is not considered part of the crate\'s public API. It is subject to"},
{"lineNum":"  857","line":"// change at any time."},
{"lineNum":"  858","line":"#[doc(hidden)]"},
{"lineNum":"  859","line":"pub fn __enabled(level: LogLevel, target: &str) -> bool {"},
{"lineNum":"  860","line":"    if let Some(logger) = logger() {"},
{"lineNum":"  861","line":"        logger.enabled(&LogMetadata { level: level, target: target })"},
{"lineNum":"  862","line":"    } else {"},
{"lineNum":"  863","line":"        false"},
{"lineNum":"  864","line":"    }"},
{"lineNum":"  865","line":"}"},
{"lineNum":"  866","line":""},
{"lineNum":"  867","line":"// WARNING"},
{"lineNum":"  868","line":"// This is not considered part of the crate\'s public API. It is subject to"},
{"lineNum":"  869","line":"// change at any time."},
{"lineNum":"  870","line":"#[doc(hidden)]"},
{"lineNum":"  871","line":"pub fn __log(level: LogLevel, target: &str, loc: &LogLocation,"},
{"lineNum":"  872","line":"             args: fmt::Arguments) {","class":"lineNoCov","hits":"0",},
{"lineNum":"  873","line":"    if let Some(logger) = logger() {","class":"lineNoCov","hits":"0",},
{"lineNum":"  874","line":"        let record = LogRecord {"},
{"lineNum":"  875","line":"            metadata: LogMetadata {"},
{"lineNum":"  876","line":"                level: level,"},
{"lineNum":"  877","line":"                target: target,"},
{"lineNum":"  878","line":"            },"},
{"lineNum":"  879","line":"            location: loc,","class":"lineNoCov","hits":"0",},
{"lineNum":"  880","line":"            args: args"},
{"lineNum":"  881","line":"        };"},
{"lineNum":"  882","line":"        logger.log(&record)","class":"lineNoCov","hits":"0",},
{"lineNum":"  883","line":"    }"},
{"lineNum":"  884","line":"}","class":"lineNoCov","hits":"0",},
{"lineNum":"  885","line":""},
{"lineNum":"  886","line":"// WARNING"},
{"lineNum":"  887","line":"// This is not considered part of the crate\'s public API. It is subject to"},
{"lineNum":"  888","line":"// change at any time."},
{"lineNum":"  889","line":"#[inline(always)]"},
{"lineNum":"  890","line":"#[doc(hidden)]"},
{"lineNum":"  891","line":"pub fn __static_max_level() -> LogLevelFilter {"},
{"lineNum":"  892","line":"    if !cfg!(debug_assertions) {"},
{"lineNum":"  893","line":"        // This is a release build. Check `release_max_level_*` first."},
{"lineNum":"  894","line":"        if cfg!(feature = \"release_max_level_off\") {"},
{"lineNum":"  895","line":"            return LogLevelFilter::Off"},
{"lineNum":"  896","line":"        } else if cfg!(feature = \"release_max_level_error\") {"},
{"lineNum":"  897","line":"            return LogLevelFilter::Error"},
{"lineNum":"  898","line":"        } else if cfg!(feature = \"release_max_level_warn\") {"},
{"lineNum":"  899","line":"            return LogLevelFilter::Warn"},
{"lineNum":"  900","line":"        } else if cfg!(feature = \"release_max_level_info\") {"},
{"lineNum":"  901","line":"            return LogLevelFilter::Info"},
{"lineNum":"  902","line":"        } else if cfg!(feature = \"release_max_level_debug\") {"},
{"lineNum":"  903","line":"            return LogLevelFilter::Debug"},
{"lineNum":"  904","line":"        } else if cfg!(feature = \"release_max_level_trace\") {"},
{"lineNum":"  905","line":"            return LogLevelFilter::Trace"},
{"lineNum":"  906","line":"        }"},
{"lineNum":"  907","line":"    }"},
{"lineNum":"  908","line":"    if cfg!(feature = \"max_level_off\") {"},
{"lineNum":"  909","line":"        LogLevelFilter::Off"},
{"lineNum":"  910","line":"    } else if cfg!(feature = \"max_level_error\") {"},
{"lineNum":"  911","line":"        LogLevelFilter::Error"},
{"lineNum":"  912","line":"    } else if cfg!(feature = \"max_level_warn\") {"},
{"lineNum":"  913","line":"        LogLevelFilter::Warn"},
{"lineNum":"  914","line":"    } else if cfg!(feature = \"max_level_info\") {"},
{"lineNum":"  915","line":"        LogLevelFilter::Info"},
{"lineNum":"  916","line":"    } else if cfg!(feature = \"max_level_debug\") {"},
{"lineNum":"  917","line":"        LogLevelFilter::Debug"},
{"lineNum":"  918","line":"    } else {"},
{"lineNum":"  919","line":"        LogLevelFilter::Trace"},
{"lineNum":"  920","line":"    }"},
{"lineNum":"  921","line":"}"},
{"lineNum":"  922","line":""},
{"lineNum":"  923","line":"#[cfg(test)]"},
{"lineNum":"  924","line":"mod tests {"},
{"lineNum":"  925","line":"     extern crate std;"},
{"lineNum":"  926","line":"     use tests::std::string::ToString;"},
{"lineNum":"  927","line":"     use super::{LogLevel, LogLevelFilter};"},
{"lineNum":"  928","line":""},
{"lineNum":"  929","line":"     #[test]"},
{"lineNum":"  930","line":"     fn test_loglevelfilter_from_str() {"},
{"lineNum":"  931","line":"         let tests = ["},
{"lineNum":"  932","line":"             (\"off\",   Ok(LogLevelFilter::Off)),"},
{"lineNum":"  933","line":"             (\"error\", Ok(LogLevelFilter::Error)),"},
{"lineNum":"  934","line":"             (\"warn\",  Ok(LogLevelFilter::Warn)),"},
{"lineNum":"  935","line":"             (\"info\",  Ok(LogLevelFilter::Info)),"},
{"lineNum":"  936","line":"             (\"debug\", Ok(LogLevelFilter::Debug)),"},
{"lineNum":"  937","line":"             (\"trace\", Ok(LogLevelFilter::Trace)),"},
{"lineNum":"  938","line":"             (\"OFF\",   Ok(LogLevelFilter::Off)),"},
{"lineNum":"  939","line":"             (\"ERROR\", Ok(LogLevelFilter::Error)),"},
{"lineNum":"  940","line":"             (\"WARN\",  Ok(LogLevelFilter::Warn)),"},
{"lineNum":"  941","line":"             (\"INFO\",  Ok(LogLevelFilter::Info)),"},
{"lineNum":"  942","line":"             (\"DEBUG\", Ok(LogLevelFilter::Debug)),"},
{"lineNum":"  943","line":"             (\"TRACE\", Ok(LogLevelFilter::Trace)),"},
{"lineNum":"  944","line":"             (\"asdf\",  Err(())),"},
{"lineNum":"  945","line":"         ];"},
{"lineNum":"  946","line":"         for &(s, ref expected) in &tests {"},
{"lineNum":"  947","line":"             assert_eq!(expected, &s.parse());"},
{"lineNum":"  948","line":"         }"},
{"lineNum":"  949","line":"     }"},
{"lineNum":"  950","line":""},
{"lineNum":"  951","line":"     #[test]"},
{"lineNum":"  952","line":"     fn test_loglevel_from_str() {"},
{"lineNum":"  953","line":"         let tests = ["},
{"lineNum":"  954","line":"             (\"OFF\",   Err(())),"},
{"lineNum":"  955","line":"             (\"error\", Ok(LogLevel::Error)),"},
{"lineNum":"  956","line":"             (\"warn\",  Ok(LogLevel::Warn)),"},
{"lineNum":"  957","line":"             (\"info\",  Ok(LogLevel::Info)),"},
{"lineNum":"  958","line":"             (\"debug\", Ok(LogLevel::Debug)),"},
{"lineNum":"  959","line":"             (\"trace\", Ok(LogLevel::Trace)),"},
{"lineNum":"  960","line":"             (\"ERROR\", Ok(LogLevel::Error)),"},
{"lineNum":"  961","line":"             (\"WARN\",  Ok(LogLevel::Warn)),"},
{"lineNum":"  962","line":"             (\"INFO\",  Ok(LogLevel::Info)),"},
{"lineNum":"  963","line":"             (\"DEBUG\", Ok(LogLevel::Debug)),"},
{"lineNum":"  964","line":"             (\"TRACE\", Ok(LogLevel::Trace)),"},
{"lineNum":"  965","line":"             (\"asdf\",  Err(())),"},
{"lineNum":"  966","line":"         ];"},
{"lineNum":"  967","line":"         for &(s, ref expected) in &tests {"},
{"lineNum":"  968","line":"             assert_eq!(expected, &s.parse());"},
{"lineNum":"  969","line":"         }"},
{"lineNum":"  970","line":"     }"},
{"lineNum":"  971","line":""},
{"lineNum":"  972","line":"     #[test]"},
{"lineNum":"  973","line":"     fn test_loglevel_show() {"},
{"lineNum":"  974","line":"         assert_eq!(\"INFO\", LogLevel::Info.to_string());"},
{"lineNum":"  975","line":"         assert_eq!(\"ERROR\", LogLevel::Error.to_string());"},
{"lineNum":"  976","line":"     }"},
{"lineNum":"  977","line":""},
{"lineNum":"  978","line":"     #[test]"},
{"lineNum":"  979","line":"     fn test_loglevelfilter_show() {"},
{"lineNum":"  980","line":"         assert_eq!(\"OFF\", LogLevelFilter::Off.to_string());"},
{"lineNum":"  981","line":"         assert_eq!(\"ERROR\", LogLevelFilter::Error.to_string());"},
{"lineNum":"  982","line":"     }"},
{"lineNum":"  983","line":""},
{"lineNum":"  984","line":"     #[test]"},
{"lineNum":"  985","line":"     fn test_cross_cmp() {"},
{"lineNum":"  986","line":"         assert!(LogLevel::Debug > LogLevelFilter::Error);"},
{"lineNum":"  987","line":"         assert!(LogLevelFilter::Warn < LogLevel::Trace);"},
{"lineNum":"  988","line":"         assert!(LogLevelFilter::Off < LogLevel::Error);"},
{"lineNum":"  989","line":"     }"},
{"lineNum":"  990","line":""},
{"lineNum":"  991","line":"     #[test]"},
{"lineNum":"  992","line":"     fn test_cross_eq() {"},
{"lineNum":"  993","line":"         assert!(LogLevel::Error == LogLevelFilter::Error);"},
{"lineNum":"  994","line":"         assert!(LogLevelFilter::Off != LogLevel::Error);"},
{"lineNum":"  995","line":"         assert!(LogLevel::Trace == LogLevelFilter::Trace);"},
{"lineNum":"  996","line":"     }"},
{"lineNum":"  997","line":""},
{"lineNum":"  998","line":"     #[test]"},
{"lineNum":"  999","line":"     fn test_to_log_level() {"},
{"lineNum":" 1000","line":"         assert_eq!(Some(LogLevel::Error), LogLevelFilter::Error.to_log_level());"},
{"lineNum":" 1001","line":"         assert_eq!(None, LogLevelFilter::Off.to_log_level());"},
{"lineNum":" 1002","line":"         assert_eq!(Some(LogLevel::Debug), LogLevelFilter::Debug.to_log_level());"},
{"lineNum":" 1003","line":"     }"},
{"lineNum":" 1004","line":""},
{"lineNum":" 1005","line":"     #[test]"},
{"lineNum":" 1006","line":"     fn test_to_log_level_filter() {"},
{"lineNum":" 1007","line":"         assert_eq!(LogLevelFilter::Error, LogLevel::Error.to_log_level_filter());"},
{"lineNum":" 1008","line":"         assert_eq!(LogLevelFilter::Trace, LogLevel::Trace.to_log_level_filter());"},
{"lineNum":" 1009","line":"     }"},
{"lineNum":" 1010","line":""},
{"lineNum":" 1011","line":"     #[test]"},
{"lineNum":" 1012","line":"     #[cfg(feature = \"use_std\")]"},
{"lineNum":" 1013","line":"     fn test_error_trait() {"},
{"lineNum":" 1014","line":"         use std::error::Error;"},
{"lineNum":" 1015","line":"         use super::SetLoggerError;"},
{"lineNum":" 1016","line":"         let e = SetLoggerError(());"},
{"lineNum":" 1017","line":"         assert_eq!(e.description(), \"set_logger() called multiple times\");"},
{"lineNum":" 1018","line":"     }"},
{"lineNum":" 1019","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test_server-9ef2987148640087", "date" : "2016-02-17 13:46:05", "instrumented" : 20, "covered" : 3,};
var merged_data = [];
