var data = {lines:[
{"lineNum":"    1","line":"// Copyright 2015 The Rust Project Developers. See the COPYRIGHT"},
{"lineNum":"    2","line":"// file at the top-level directory of this distribution and at","class":"lineNoCov","hits":"0",},
{"lineNum":"    3","line":"// http://rust-lang.org/COPYRIGHT."},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or"},
{"lineNum":"    6","line":"// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license"},
{"lineNum":"    7","line":"// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your"},
{"lineNum":"    8","line":"// option. This file may not be copied, modified, or distributed"},
{"lineNum":"    9","line":"// except according to those terms."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#![allow(bad_style, dead_code)]"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"use std::io;"},
{"lineNum":"   14","line":"use std::mem;"},
{"lineNum":"   15","line":"use std::net::{TcpStream, TcpListener, UdpSocket, Ipv4Addr, Ipv6Addr};"},
{"lineNum":"   16","line":"use std::net::ToSocketAddrs;"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"use {TcpBuilder, UdpBuilder, FromInner};"},
{"lineNum":"   19","line":"use sys;"},
{"lineNum":"   20","line":"use socket;"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"cfg_if! {"},
{"lineNum":"   23","line":"    if #[cfg(any(target_os = \"freebsd\", target_os = \"macos\","},
{"lineNum":"   24","line":"                 target_os = \"ios\", target_os = \"dragonfly\"))] {"},
{"lineNum":"   25","line":"        use libc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;"},
{"lineNum":"   26","line":"        use libc::IPV6_LEAVE_GROUP as IPV6_DROP_MEMBERSHIP;"},
{"lineNum":"   27","line":"    } else {"},
{"lineNum":"   28","line":"        // ..."},
{"lineNum":"   29","line":"    }"},
{"lineNum":"   30","line":"}"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"#[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"   33","line":"use std::time::Duration;"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"#[cfg(unix)] pub type Socket = c_int;"},
{"lineNum":"   36","line":"#[cfg(unix)] use std::os::unix::prelude::*;"},
{"lineNum":"   37","line":"#[cfg(unix)] use libc::*;"},
{"lineNum":"   38","line":"#[cfg(windows)] pub type Socket = SOCKET;"},
{"lineNum":"   39","line":"#[cfg(windows)] use std::os::windows::prelude::*;"},
{"lineNum":"   40","line":"#[cfg(windows)] use ws2_32::*;"},
{"lineNum":"   41","line":"#[cfg(windows)] use winapi::*;"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"#[cfg(windows)] const SIO_KEEPALIVE_VALS: DWORD = 0x98000004;"},
{"lineNum":"   44","line":"#[cfg(windows)]"},
{"lineNum":"   45","line":"#[repr(C)]"},
{"lineNum":"   46","line":"struct tcp_keepalive {"},
{"lineNum":"   47","line":"    onoff: c_ulong,"},
{"lineNum":"   48","line":"    keepalivetime: c_ulong,"},
{"lineNum":"   49","line":"    keepaliveinterval: c_ulong,"},
{"lineNum":"   50","line":"}"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"#[cfg(windows)] fn v(opt: IPPROTO) -> c_int { opt.0 as c_int }"},
{"lineNum":"   53","line":"#[cfg(unix)] fn v(opt: c_int) -> c_int { opt }"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"pub fn set_opt<T: Copy>(sock: Socket, opt: c_int, val: c_int,"},
{"lineNum":"   56","line":"                       payload: T) -> io::Result<()> {","class":"lineCov","hits":"1","order":"1417",},
{"lineNum":"   57","line":"    unsafe {"},
{"lineNum":"   58","line":"        let payload = &payload as *const T as *const c_void;","class":"lineCov","hits":"1","order":"1418",},
{"lineNum":"   59","line":"        try!(::cvt(setsockopt(sock, opt, val, payload as *const _,","class":"lineCov","hits":"1","order":"1419",},
{"lineNum":"   60","line":"                              mem::size_of::<T>() as socklen_t)));","class":"lineCov","hits":"1","order":"1420",},
{"lineNum":"   61","line":"        Ok(())"},
{"lineNum":"   62","line":"    }","class":"lineCov","hits":"1","order":"1421",},
{"lineNum":"   63","line":"}","class":"lineCov","hits":"1","order":"1422",},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"fn get_opt<T: Copy>(sock: Socket, opt: c_int, val: c_int) -> io::Result<T> {"},
{"lineNum":"   66","line":"    unsafe {"},
{"lineNum":"   67","line":"        let mut slot: T = mem::zeroed();"},
{"lineNum":"   68","line":"        let mut len = mem::size_of::<T>() as socklen_t;"},
{"lineNum":"   69","line":"        try!(::cvt(getsockopt(sock, opt, val,"},
{"lineNum":"   70","line":"                              &mut slot as *mut _ as *mut _,"},
{"lineNum":"   71","line":"                              &mut len)));"},
{"lineNum":"   72","line":"        assert_eq!(len as usize, mem::size_of::<T>());"},
{"lineNum":"   73","line":"        Ok(slot)"},
{"lineNum":"   74","line":"    }"},
{"lineNum":"   75","line":"}"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"/// Extension methods for the standard [`TcpStream` type][link] in `std::net`."},
{"lineNum":"   78","line":"///"},
{"lineNum":"   79","line":"/// [link]: https://doc.rust-lang.org/std/net/struct.TcpStream.html"},
{"lineNum":"   80","line":"pub trait TcpStreamExt {"},
{"lineNum":"   81","line":"    /// Sets the value of the `TCP_NODELAY` option on this socket."},
{"lineNum":"   82","line":"    ///"},
{"lineNum":"   83","line":"    /// If set, this option disables the Nagle algorithm. This means that"},
{"lineNum":"   84","line":"    /// segments are always sent as soon as possible, even if there is only a"},
{"lineNum":"   85","line":"    /// small amount of data. When not set, data is buffered until there is a"},
{"lineNum":"   86","line":"    /// sufficient amount to send out, thereby avoiding the frequent sending of"},
{"lineNum":"   87","line":"    /// small packets."},
{"lineNum":"   88","line":"    fn set_nodelay(&self, nodelay: bool) -> io::Result<()>;"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"    /// Gets the value of the `TCP_NODELAY` option on this socket."},
{"lineNum":"   91","line":"    ///"},
{"lineNum":"   92","line":"    /// For more information about this option, see [`set_nodelay`][link]."},
{"lineNum":"   93","line":"    ///"},
{"lineNum":"   94","line":"    /// [link]: #tymethod.set_nodelay"},
{"lineNum":"   95","line":"    fn nodelay(&self) -> io::Result<bool>;"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"    /// Sets whether keepalive messages are enabled to be sent on this socket."},
{"lineNum":"   98","line":"    ///"},
{"lineNum":"   99","line":"    /// On Unix, this option will set the `SO_KEEPALIVE` as well as the"},
{"lineNum":"  100","line":"    /// `TCP_KEEPALIVE` or `TCP_KEEPIDLE` option (depending on your platform)."},
{"lineNum":"  101","line":"    /// On Windows, this will set the `SIO_KEEPALIVE_VALS` option."},
{"lineNum":"  102","line":"    ///"},
{"lineNum":"  103","line":"    /// If `None` is specified then keepalive messages are disabled, otherwise"},
{"lineNum":"  104","line":"    /// the number of milliseconds specified will be the time to remain idle"},
{"lineNum":"  105","line":"    /// before sending a TCP keepalive probe."},
{"lineNum":"  106","line":"    ///"},
{"lineNum":"  107","line":"    /// Some platforms specify this value in seconds, so sub-second millisecond"},
{"lineNum":"  108","line":"    /// specifications may be omitted."},
{"lineNum":"  109","line":"    fn set_keepalive_ms(&self, keepalive: Option<u32>) -> io::Result<()>;"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"    /// Returns whether keepalive messages are enabled on this socket, and if so"},
{"lineNum":"  112","line":"    /// the amount of milliseconds between them."},
{"lineNum":"  113","line":"    ///"},
{"lineNum":"  114","line":"    /// For more information about this option, see [`set_keepalive_ms`][link]."},
{"lineNum":"  115","line":"    ///"},
{"lineNum":"  116","line":"    /// [link]: #tymethod.set_keepalive_ms"},
{"lineNum":"  117","line":"    fn keepalive_ms(&self) -> io::Result<Option<u32>>;"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"    /// Sets whether keepalive messages are enabled to be sent on this socket."},
{"lineNum":"  120","line":"    ///"},
{"lineNum":"  121","line":"    /// On Unix, this option will set the `SO_KEEPALIVE` as well as the"},
{"lineNum":"  122","line":"    /// `TCP_KEEPALIVE` or `TCP_KEEPIDLE` option (depending on your platform)."},
{"lineNum":"  123","line":"    /// On Windows, this will set the `SIO_KEEPALIVE_VALS` option."},
{"lineNum":"  124","line":"    ///"},
{"lineNum":"  125","line":"    /// If `None` is specified then keepalive messages are disabled, otherwise"},
{"lineNum":"  126","line":"    /// the duration specified will be the time to remain idle before sending a"},
{"lineNum":"  127","line":"    /// TCP keepalive probe."},
{"lineNum":"  128","line":"    ///"},
{"lineNum":"  129","line":"    /// Some platforms specify this value in seconds, so sub-second"},
{"lineNum":"  130","line":"    /// specifications may be omitted."},
{"lineNum":"  131","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  132","line":"    fn set_keepalive(&self, keepalive: Option<Duration>) -> io::Result<()>;"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"    /// Returns whether keepalive messages are enabled on this socket, and if so"},
{"lineNum":"  135","line":"    /// the duration of time between them."},
{"lineNum":"  136","line":"    ///"},
{"lineNum":"  137","line":"    /// For more information about this option, see [`set_keepalive`][link]."},
{"lineNum":"  138","line":"    ///"},
{"lineNum":"  139","line":"    /// [link]: #tymethod.set_keepalive"},
{"lineNum":"  140","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  141","line":"    fn keepalive(&self) -> io::Result<Option<Duration>>;"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"    /// Sets the `SO_RCVTIMEO` option for this socket."},
{"lineNum":"  144","line":"    ///"},
{"lineNum":"  145","line":"    /// This option specifies the timeout, in milliseconds, of how long calls to"},
{"lineNum":"  146","line":"    /// this socket\'s `read` function will wait before returning a timeout. A"},
{"lineNum":"  147","line":"    /// value of `None` means that no read timeout should be specified and"},
{"lineNum":"  148","line":"    /// otherwise `Some` indicates the number of milliseconds for the timeout."},
{"lineNum":"  149","line":"    fn set_read_timeout_ms(&self, val: Option<u32>) -> io::Result<()>;"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"    /// Sets the `SO_RCVTIMEO` option for this socket."},
{"lineNum":"  152","line":"    ///"},
{"lineNum":"  153","line":"    /// This option specifies the timeout of how long calls to this socket\'s"},
{"lineNum":"  154","line":"    /// `read` function will wait before returning a timeout. A value of `None`"},
{"lineNum":"  155","line":"    /// means that no read timeout should be specified and otherwise `Some`"},
{"lineNum":"  156","line":"    /// indicates the number of duration of the timeout."},
{"lineNum":"  157","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  158","line":"    fn set_read_timeout(&self, val: Option<Duration>) -> io::Result<()>;"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"    /// Gets the value of the `SO_RCVTIMEO` option for this socket."},
{"lineNum":"  161","line":"    ///"},
{"lineNum":"  162","line":"    /// For more information about this option, see [`set_read_timeout_ms`][link]."},
{"lineNum":"  163","line":"    ///"},
{"lineNum":"  164","line":"    /// [link]: #tymethod.set_read_timeout_ms"},
{"lineNum":"  165","line":"    fn read_timeout_ms(&self) -> io::Result<Option<u32>>;"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"    /// Gets the value of the `SO_RCVTIMEO` option for this socket."},
{"lineNum":"  168","line":"    ///"},
{"lineNum":"  169","line":"    /// For more information about this option, see [`set_read_timeout`][link]."},
{"lineNum":"  170","line":"    ///"},
{"lineNum":"  171","line":"    /// [link]: #tymethod.set_read_timeout"},
{"lineNum":"  172","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  173","line":"    fn read_timeout(&self) -> io::Result<Option<Duration>>;"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"    /// Sets the `SO_SNDTIMEO` option for this socket."},
{"lineNum":"  176","line":"    ///"},
{"lineNum":"  177","line":"    /// This option specifies the timeout, in milliseconds, of how long calls to"},
{"lineNum":"  178","line":"    /// this socket\'s `write` function will wait before returning a timeout. A"},
{"lineNum":"  179","line":"    /// value of `None` means that no read timeout should be specified and"},
{"lineNum":"  180","line":"    /// otherwise `Some` indicates the number of milliseconds for the timeout."},
{"lineNum":"  181","line":"    fn set_write_timeout_ms(&self, val: Option<u32>) -> io::Result<()>;"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"    /// Sets the `SO_SNDTIMEO` option for this socket."},
{"lineNum":"  184","line":"    ///"},
{"lineNum":"  185","line":"    /// This option specifies the timeout of how long calls to this socket\'s"},
{"lineNum":"  186","line":"    /// `write` function will wait before returning a timeout. A value of `None`"},
{"lineNum":"  187","line":"    /// means that no read timeout should be specified and otherwise `Some`"},
{"lineNum":"  188","line":"    /// indicates the duration of the timeout."},
{"lineNum":"  189","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  190","line":"    fn set_write_timeout(&self, val: Option<Duration>) -> io::Result<()>;"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"    /// Gets the value of the `SO_SNDTIMEO` option for this socket."},
{"lineNum":"  193","line":"    ///"},
{"lineNum":"  194","line":"    /// For more information about this option, see [`set_write_timeout_ms`][link]."},
{"lineNum":"  195","line":"    ///"},
{"lineNum":"  196","line":"    /// [link]: #tymethod.set_write_timeout_ms"},
{"lineNum":"  197","line":"    fn write_timeout_ms(&self) -> io::Result<Option<u32>>;"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"    /// Gets the value of the `SO_SNDTIMEO` option for this socket."},
{"lineNum":"  200","line":"    ///"},
{"lineNum":"  201","line":"    /// For more information about this option, see [`set_write_timeout`][link]."},
{"lineNum":"  202","line":"    ///"},
{"lineNum":"  203","line":"    /// [link]: #tymethod.set_write_timeout"},
{"lineNum":"  204","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  205","line":"    fn write_timeout(&self) -> io::Result<Option<Duration>>;"},
{"lineNum":"  206","line":""},
{"lineNum":"  207","line":"    /// Sets the value for the `IP_TTL` option on this socket."},
{"lineNum":"  208","line":"    ///"},
{"lineNum":"  209","line":"    /// This value sets the time-to-live field that is used in every packet sent"},
{"lineNum":"  210","line":"    /// from this socket."},
{"lineNum":"  211","line":"    fn set_ttl(&self, ttl: u32) -> io::Result<()>;"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"    /// Gets the value of the `IP_TTL` option for this socket."},
{"lineNum":"  214","line":"    ///"},
{"lineNum":"  215","line":"    /// For more information about this option, see [`set_ttl`][link]."},
{"lineNum":"  216","line":"    ///"},
{"lineNum":"  217","line":"    /// [link]: #tymethod.set_ttl"},
{"lineNum":"  218","line":"    fn ttl(&self) -> io::Result<u32>;"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"    /// Sets the value for the `IPV6_V6ONLY` option on this socket."},
{"lineNum":"  221","line":"    ///"},
{"lineNum":"  222","line":"    /// If this is set to `true` then the socket is restricted to sending and"},
{"lineNum":"  223","line":"    /// receiving IPv6 packets only. In this case two IPv4 and IPv6 applications"},
{"lineNum":"  224","line":"    /// can bind the same port at the same time."},
{"lineNum":"  225","line":"    ///"},
{"lineNum":"  226","line":"    /// If this is set to `false` then the socket can be used to send and"},
{"lineNum":"  227","line":"    /// receive packets from an IPv4-mapped IPv6 address."},
{"lineNum":"  228","line":"    fn set_only_v6(&self, only_v6: bool) -> io::Result<()>;"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"    /// Gets the value of the `IPV6_V6ONLY` option for this socket."},
{"lineNum":"  231","line":"    ///"},
{"lineNum":"  232","line":"    /// For more information about this option, see [`set_only_v6`][link]."},
{"lineNum":"  233","line":"    ///"},
{"lineNum":"  234","line":"    /// [link]: #tymethod.set_only_v6"},
{"lineNum":"  235","line":"    fn only_v6(&self) -> io::Result<bool>;"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"    /// Executes a `connect` operation on this socket, establishing a connection"},
{"lineNum":"  238","line":"    /// to the host specified by `addr`."},
{"lineNum":"  239","line":"    ///"},
{"lineNum":"  240","line":"    /// Note that this normally does not need to be called on a `TcpStream`,"},
{"lineNum":"  241","line":"    /// it\'s typically automatically done as part of a normal"},
{"lineNum":"  242","line":"    /// `TcpStream::connect` function call or `TcpBuilder::connect` method call."},
{"lineNum":"  243","line":"    ///"},
{"lineNum":"  244","line":"    /// This should only be necessary if an unconnected socket was extracted"},
{"lineNum":"  245","line":"    /// from a `TcpBuilder` and then needs to be connected."},
{"lineNum":"  246","line":"    fn connect<T: ToSocketAddrs>(&self, addr: T) -> io::Result<()>;"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"    /// Get the value of the `SO_ERROR` option on this socket."},
{"lineNum":"  249","line":"    ///"},
{"lineNum":"  250","line":"    /// This will retrieve the stored error in the underlying socket, clearing"},
{"lineNum":"  251","line":"    /// the field in the process. This can be useful for checking errors between"},
{"lineNum":"  252","line":"    /// calls."},
{"lineNum":"  253","line":"    fn take_error(&self) -> io::Result<Option<io::Error>>;"},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"    /// Moves this TCP stream into or out of nonblocking mode."},
{"lineNum":"  256","line":"    ///"},
{"lineNum":"  257","line":"    /// On Unix this corresponds to calling fcntl, and on Windows this"},
{"lineNum":"  258","line":"    /// corresponds to calling ioctlsocket."},
{"lineNum":"  259","line":"    fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()>;"},
{"lineNum":"  260","line":"}"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"/// Extension methods for the standard [`TcpListener` type][link] in `std::net`."},
{"lineNum":"  263","line":"///"},
{"lineNum":"  264","line":"/// [link]: https://doc.rust-lang.org/std/net/struct.TcpListener.html"},
{"lineNum":"  265","line":"pub trait TcpListenerExt {"},
{"lineNum":"  266","line":"    /// Sets the value for the `IP_TTL` option on this socket."},
{"lineNum":"  267","line":"    ///"},
{"lineNum":"  268","line":"    /// This is the same as [`TcpStreamExt::set_ttl`][other]."},
{"lineNum":"  269","line":"    ///"},
{"lineNum":"  270","line":"    /// [other]: trait.TcpStreamExt.html#tymethod.set_ttl"},
{"lineNum":"  271","line":"    fn set_ttl(&self, ttl: u32) -> io::Result<()>;"},
{"lineNum":"  272","line":""},
{"lineNum":"  273","line":"    /// Gets the value of the `IP_TTL` option for this socket."},
{"lineNum":"  274","line":"    ///"},
{"lineNum":"  275","line":"    /// For more information about this option, see"},
{"lineNum":"  276","line":"    /// [`TcpStreamExt::set_ttl`][link]."},
{"lineNum":"  277","line":"    ///"},
{"lineNum":"  278","line":"    /// [link]: trait.TcpStreamExt.html#tymethod.set_ttl"},
{"lineNum":"  279","line":"    fn ttl(&self) -> io::Result<u32>;"},
{"lineNum":"  280","line":""},
{"lineNum":"  281","line":"    /// Sets the value for the `IPV6_V6ONLY` option on this socket."},
{"lineNum":"  282","line":"    ///"},
{"lineNum":"  283","line":"    /// For more information about this option, see"},
{"lineNum":"  284","line":"    /// [`TcpStreamExt::set_only_v6`][link]."},
{"lineNum":"  285","line":"    ///"},
{"lineNum":"  286","line":"    /// [link]: trait.TcpStreamExt.html#tymethod.set_only_v6"},
{"lineNum":"  287","line":"    fn set_only_v6(&self, only_v6: bool) -> io::Result<()>;"},
{"lineNum":"  288","line":""},
{"lineNum":"  289","line":"    /// Gets the value of the `IPV6_V6ONLY` option for this socket."},
{"lineNum":"  290","line":"    ///"},
{"lineNum":"  291","line":"    /// For more information about this option, see"},
{"lineNum":"  292","line":"    /// [`TcpStreamExt::set_only_v6`][link]."},
{"lineNum":"  293","line":"    ///"},
{"lineNum":"  294","line":"    /// [link]: trait.TcpStreamExt.html#tymethod.set_only_v6"},
{"lineNum":"  295","line":"    fn only_v6(&self) -> io::Result<bool>;"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"    /// Get the value of the `SO_ERROR` option on this socket."},
{"lineNum":"  298","line":"    ///"},
{"lineNum":"  299","line":"    /// This will retrieve the stored error in the underlying socket, clearing"},
{"lineNum":"  300","line":"    /// the field in the process. This can be useful for checking errors between"},
{"lineNum":"  301","line":"    /// calls."},
{"lineNum":"  302","line":"    fn take_error(&self) -> io::Result<Option<io::Error>>;"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"    /// Moves this TCP listener into or out of nonblocking mode."},
{"lineNum":"  305","line":"    ///"},
{"lineNum":"  306","line":"    /// For more information about this option, see"},
{"lineNum":"  307","line":"    /// [`TcpStreamExt::set_nonblocking`][link]."},
{"lineNum":"  308","line":"    ///"},
{"lineNum":"  309","line":"    /// [link]: trait.TcpStreamExt.html#tymethod.set_nonblocking"},
{"lineNum":"  310","line":"    fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()>;"},
{"lineNum":"  311","line":"}"},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"/// Extension methods for the standard [`UdpSocket` type][link] in `std::net`."},
{"lineNum":"  314","line":"///"},
{"lineNum":"  315","line":"/// [link]: https://doc.rust-lang.org/std/net/struct.UdpSocket.html"},
{"lineNum":"  316","line":"pub trait UdpSocketExt {"},
{"lineNum":"  317","line":"    /// Sets the value of the `SO_BROADCAST` option for this socket."},
{"lineNum":"  318","line":"    ///"},
{"lineNum":"  319","line":"    /// When enabled, this socket is allowed to send packets to a broadcast"},
{"lineNum":"  320","line":"    /// address."},
{"lineNum":"  321","line":"    fn set_broadcast(&self, broadcast: bool) -> io::Result<()>;"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"    /// Gets the value of the `SO_BROADCAST` option for this socket."},
{"lineNum":"  324","line":"    ///"},
{"lineNum":"  325","line":"    /// For more information about this option, see"},
{"lineNum":"  326","line":"    /// [`set_broadcast`][link]."},
{"lineNum":"  327","line":"    ///"},
{"lineNum":"  328","line":"    /// [link]: #tymethod.set_broadcast"},
{"lineNum":"  329","line":"    fn broadcast(&self) -> io::Result<bool>;"},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"    /// Sets the value of the `IP_MULTICAST_LOOP` option for this socket."},
{"lineNum":"  332","line":"    ///"},
{"lineNum":"  333","line":"    /// If enabled, multicast packets will be looped back to the local socket."},
{"lineNum":"  334","line":"    /// Note that this may not have any affect on IPv6 sockets."},
{"lineNum":"  335","line":"    fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()>;"},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"    /// Gets the value of the `IP_MULTICAST_LOOP` option for this socket."},
{"lineNum":"  338","line":"    ///"},
{"lineNum":"  339","line":"    /// For more information about this option, see"},
{"lineNum":"  340","line":"    /// [`set_multicast_loop_v4`][link]."},
{"lineNum":"  341","line":"    ///"},
{"lineNum":"  342","line":"    /// [link]: #tymethod.set_multicast_loop_v4"},
{"lineNum":"  343","line":"    fn multicast_loop_v4(&self) -> io::Result<bool>;"},
{"lineNum":"  344","line":""},
{"lineNum":"  345","line":"    /// Sets the value of the `IP_MULTICAST_TTL` option for this socket."},
{"lineNum":"  346","line":"    ///"},
{"lineNum":"  347","line":"    /// Indicates the time-to-live value of outgoing multicast packets for"},
{"lineNum":"  348","line":"    /// this socket. The default value is 1 which means that multicast packets"},
{"lineNum":"  349","line":"    /// don\'t leave the local network unless explicitly requested."},
{"lineNum":"  350","line":"    ///"},
{"lineNum":"  351","line":"    /// Note that this may not have any affect on IPv6 sockets."},
{"lineNum":"  352","line":"    fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()>;"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"    /// Gets the value of the `IP_MULTICAST_TTL` option for this socket."},
{"lineNum":"  355","line":"    ///"},
{"lineNum":"  356","line":"    /// For more information about this option, see"},
{"lineNum":"  357","line":"    /// [`set_multicast_ttl_v4`][link]."},
{"lineNum":"  358","line":"    ///"},
{"lineNum":"  359","line":"    /// [link]: #tymethod.set_multicast_ttl_v4"},
{"lineNum":"  360","line":"    fn multicast_ttl_v4(&self) -> io::Result<u32>;"},
{"lineNum":"  361","line":""},
{"lineNum":"  362","line":"    /// Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket."},
{"lineNum":"  363","line":"    ///"},
{"lineNum":"  364","line":"    /// Controls whether this socket sees the multicast packets it sends itself."},
{"lineNum":"  365","line":"    /// Note that this may not have any affect on IPv4 sockets."},
{"lineNum":"  366","line":"    fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()>;"},
{"lineNum":"  367","line":""},
{"lineNum":"  368","line":"    /// Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket."},
{"lineNum":"  369","line":"    ///"},
{"lineNum":"  370","line":"    /// For more information about this option, see"},
{"lineNum":"  371","line":"    /// [`set_multicast_loop_v6`][link]."},
{"lineNum":"  372","line":"    ///"},
{"lineNum":"  373","line":"    /// [link]: #tymethod.set_multicast_loop_v6"},
{"lineNum":"  374","line":"    fn multicast_loop_v6(&self) -> io::Result<bool>;"},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"    /// Sets the value for the `IP_TTL` option on this socket."},
{"lineNum":"  377","line":"    ///"},
{"lineNum":"  378","line":"    /// This is the same as [`TcpStreamExt::set_ttl`][other]."},
{"lineNum":"  379","line":"    ///"},
{"lineNum":"  380","line":"    /// [other]: trait.TcpStreamExt.html#tymethod.set_ttl"},
{"lineNum":"  381","line":"    fn set_ttl(&self, ttl: u32) -> io::Result<()>;"},
{"lineNum":"  382","line":""},
{"lineNum":"  383","line":"    /// Gets the value of the `IP_TTL` option for this socket."},
{"lineNum":"  384","line":"    ///"},
{"lineNum":"  385","line":"    /// For more information about this option, see"},
{"lineNum":"  386","line":"    /// [`TcpStreamExt::set_ttl`][link]."},
{"lineNum":"  387","line":"    ///"},
{"lineNum":"  388","line":"    /// [link]: trait.TcpStreamExt.html#tymethod.set_ttl"},
{"lineNum":"  389","line":"    fn ttl(&self) -> io::Result<u32>;"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"    /// Sets the value for the `IPV6_V6ONLY` option on this socket."},
{"lineNum":"  392","line":"    ///"},
{"lineNum":"  393","line":"    /// For more information about this option, see"},
{"lineNum":"  394","line":"    /// [`TcpStreamExt::set_only_v6`][link]."},
{"lineNum":"  395","line":"    ///"},
{"lineNum":"  396","line":"    /// [link]: trait.TcpStreamExt.html#tymethod.set_only_v6"},
{"lineNum":"  397","line":"    fn set_only_v6(&self, only_v6: bool) -> io::Result<()>;"},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"    /// Gets the value of the `IPV6_V6ONLY` option for this socket."},
{"lineNum":"  400","line":"    ///"},
{"lineNum":"  401","line":"    /// For more information about this option, see"},
{"lineNum":"  402","line":"    /// [`TcpStreamExt::set_only_v6`][link]."},
{"lineNum":"  403","line":"    ///"},
{"lineNum":"  404","line":"    /// [link]: trait.TcpStreamExt.html#tymethod.set_only_v6"},
{"lineNum":"  405","line":"    fn only_v6(&self) -> io::Result<bool>;"},
{"lineNum":"  406","line":""},
{"lineNum":"  407","line":"    /// Executes an operation of the `IP_ADD_MEMBERSHIP` type."},
{"lineNum":"  408","line":"    ///"},
{"lineNum":"  409","line":"    /// This function specifies a new multicast group for this socket to join."},
{"lineNum":"  410","line":"    /// The address must be a valid multicast address, and `interface` is the"},
{"lineNum":"  411","line":"    /// address of the local interface with which the system should join the"},
{"lineNum":"  412","line":"    /// multicast group. If it\'s equal to `INADDR_ANY` then an appropriate"},
{"lineNum":"  413","line":"    /// interface is chosen by the system."},
{"lineNum":"  414","line":"    fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr)"},
{"lineNum":"  415","line":"                         -> io::Result<()>;"},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":"    /// Executes an operation of the `IPV6_ADD_MEMBERSHIP` type."},
{"lineNum":"  418","line":"    ///"},
{"lineNum":"  419","line":"    /// This function specifies a new multicast group for this socket to join."},
{"lineNum":"  420","line":"    /// The address must be a valid multicast address, and `interface` is the"},
{"lineNum":"  421","line":"    /// index of the interface to join/leave (or 0 to indicate any interface)."},
{"lineNum":"  422","line":"    fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32)"},
{"lineNum":"  423","line":"                         -> io::Result<()>;"},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"    /// Executes an operation of the `IP_DROP_MEMBERSHIP` type."},
{"lineNum":"  426","line":"    ///"},
{"lineNum":"  427","line":"    /// For more information about this option, see"},
{"lineNum":"  428","line":"    /// [`join_multicast_v4`][link]."},
{"lineNum":"  429","line":"    ///"},
{"lineNum":"  430","line":"    /// [link]: #tymethod.join_multicast_v4"},
{"lineNum":"  431","line":"    fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr)"},
{"lineNum":"  432","line":"                          -> io::Result<()>;"},
{"lineNum":"  433","line":""},
{"lineNum":"  434","line":"    /// Executes an operation of the `IPV6_DROP_MEMBERSHIP` type."},
{"lineNum":"  435","line":"    ///"},
{"lineNum":"  436","line":"    /// For more information about this option, see"},
{"lineNum":"  437","line":"    /// [`join_multicast_v6`][link]."},
{"lineNum":"  438","line":"    ///"},
{"lineNum":"  439","line":"    /// [link]: #tymethod.join_multicast_v6"},
{"lineNum":"  440","line":"    fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32)"},
{"lineNum":"  441","line":"                          -> io::Result<()>;"},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":"    /// Sets the `SO_RCVTIMEO` option for this socket."},
{"lineNum":"  444","line":"    ///"},
{"lineNum":"  445","line":"    /// This option specifies the timeout, in milliseconds, of how long calls to"},
{"lineNum":"  446","line":"    /// this socket\'s `read` function will wait before returning a timeout. A"},
{"lineNum":"  447","line":"    /// value of `None` means that no read timeout should be specified and"},
{"lineNum":"  448","line":"    /// otherwise `Some` indicates the number of milliseconds for the timeout."},
{"lineNum":"  449","line":"    fn set_read_timeout_ms(&self, val: Option<u32>) -> io::Result<()>;"},
{"lineNum":"  450","line":""},
{"lineNum":"  451","line":"    /// Sets the `SO_RCVTIMEO` option for this socket."},
{"lineNum":"  452","line":"    ///"},
{"lineNum":"  453","line":"    /// This option specifies the timeout of how long calls to this socket\'s"},
{"lineNum":"  454","line":"    /// `read` function will wait before returning a timeout. A value of `None`"},
{"lineNum":"  455","line":"    /// means that no read timeout should be specified and otherwise `Some`"},
{"lineNum":"  456","line":"    /// indicates the number of duration of the timeout."},
{"lineNum":"  457","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  458","line":"    fn set_read_timeout(&self, val: Option<Duration>) -> io::Result<()>;"},
{"lineNum":"  459","line":""},
{"lineNum":"  460","line":"    /// Gets the value of the `SO_RCVTIMEO` option for this socket."},
{"lineNum":"  461","line":"    ///"},
{"lineNum":"  462","line":"    /// For more information about this option, see [`set_read_timeout_ms`][link]."},
{"lineNum":"  463","line":"    ///"},
{"lineNum":"  464","line":"    /// [link]: #tymethod.set_read_timeout_ms"},
{"lineNum":"  465","line":"    fn read_timeout_ms(&self) -> io::Result<Option<u32>>;"},
{"lineNum":"  466","line":""},
{"lineNum":"  467","line":"    /// Gets the value of the `SO_RCVTIMEO` option for this socket."},
{"lineNum":"  468","line":"    ///"},
{"lineNum":"  469","line":"    /// For more information about this option, see [`set_read_timeout`][link]."},
{"lineNum":"  470","line":"    ///"},
{"lineNum":"  471","line":"    /// [link]: #tymethod.set_read_timeout"},
{"lineNum":"  472","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  473","line":"    fn read_timeout(&self) -> io::Result<Option<Duration>>;"},
{"lineNum":"  474","line":""},
{"lineNum":"  475","line":"    /// Sets the `SO_SNDTIMEO` option for this socket."},
{"lineNum":"  476","line":"    ///"},
{"lineNum":"  477","line":"    /// This option specifies the timeout, in milliseconds, of how long calls to"},
{"lineNum":"  478","line":"    /// this socket\'s `write` function will wait before returning a timeout. A"},
{"lineNum":"  479","line":"    /// value of `None` means that no read timeout should be specified and"},
{"lineNum":"  480","line":"    /// otherwise `Some` indicates the number of milliseconds for the timeout."},
{"lineNum":"  481","line":"    fn set_write_timeout_ms(&self, val: Option<u32>) -> io::Result<()>;"},
{"lineNum":"  482","line":""},
{"lineNum":"  483","line":"    /// Sets the `SO_SNDTIMEO` option for this socket."},
{"lineNum":"  484","line":"    ///"},
{"lineNum":"  485","line":"    /// This option specifies the timeout of how long calls to this socket\'s"},
{"lineNum":"  486","line":"    /// `write` function will wait before returning a timeout. A value of `None`"},
{"lineNum":"  487","line":"    /// means that no read timeout should be specified and otherwise `Some`"},
{"lineNum":"  488","line":"    /// indicates the duration of the timeout."},
{"lineNum":"  489","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  490","line":"    fn set_write_timeout(&self, val: Option<Duration>) -> io::Result<()>;"},
{"lineNum":"  491","line":""},
{"lineNum":"  492","line":"    /// Gets the value of the `SO_SNDTIMEO` option for this socket."},
{"lineNum":"  493","line":"    ///"},
{"lineNum":"  494","line":"    /// For more information about this option, see [`set_write_timeout_ms`][link]."},
{"lineNum":"  495","line":"    ///"},
{"lineNum":"  496","line":"    /// [link]: #tymethod.set_write_timeout_ms"},
{"lineNum":"  497","line":"    fn write_timeout_ms(&self) -> io::Result<Option<u32>>;"},
{"lineNum":"  498","line":""},
{"lineNum":"  499","line":"    /// Gets the value of the `SO_SNDTIMEO` option for this socket."},
{"lineNum":"  500","line":"    ///"},
{"lineNum":"  501","line":"    /// For more information about this option, see [`set_write_timeout`][link]."},
{"lineNum":"  502","line":"    ///"},
{"lineNum":"  503","line":"    /// [link]: #tymethod.set_write_timeout"},
{"lineNum":"  504","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  505","line":"    fn write_timeout(&self) -> io::Result<Option<Duration>>;"},
{"lineNum":"  506","line":""},
{"lineNum":"  507","line":"    /// Get the value of the `SO_ERROR` option on this socket."},
{"lineNum":"  508","line":"    ///"},
{"lineNum":"  509","line":"    /// This will retrieve the stored error in the underlying socket, clearing"},
{"lineNum":"  510","line":"    /// the field in the process. This can be useful for checking errors between"},
{"lineNum":"  511","line":"    /// calls."},
{"lineNum":"  512","line":"    fn take_error(&self) -> io::Result<Option<io::Error>>;"},
{"lineNum":"  513","line":""},
{"lineNum":"  514","line":"    /// Connects this UDP socket to a remote address, allowing the `send` and"},
{"lineNum":"  515","line":"    /// `recv` syscalls to be used to send data and also applies filters to only"},
{"lineNum":"  516","line":"    /// receive data from the specified address."},
{"lineNum":"  517","line":"    fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()>;"},
{"lineNum":"  518","line":""},
{"lineNum":"  519","line":"    /// Sends data on the socket to the remote address to which it is connected."},
{"lineNum":"  520","line":"    ///"},
{"lineNum":"  521","line":"    /// The `connect` method will connect this socket to a remote address. This"},
{"lineNum":"  522","line":"    /// method will fail if the socket is not connected."},
{"lineNum":"  523","line":"    fn send(&self, buf: &[u8]) -> io::Result<usize>;"},
{"lineNum":"  524","line":""},
{"lineNum":"  525","line":"    /// Receives data on the socket from the remote address to which it is"},
{"lineNum":"  526","line":"    /// connected."},
{"lineNum":"  527","line":"    ///"},
{"lineNum":"  528","line":"    /// The `connect` method will connect this socket to a remote address. This"},
{"lineNum":"  529","line":"    /// method will fail if the socket is not connected."},
{"lineNum":"  530","line":"    fn recv(&self, buf: &mut [u8]) -> io::Result<usize>;"},
{"lineNum":"  531","line":""},
{"lineNum":"  532","line":"    /// Moves this UDP socket into or out of nonblocking mode."},
{"lineNum":"  533","line":"    ///"},
{"lineNum":"  534","line":"    /// For more information about this option, see"},
{"lineNum":"  535","line":"    /// [`TcpStreamExt::set_nonblocking`][link]."},
{"lineNum":"  536","line":"    ///"},
{"lineNum":"  537","line":"    /// [link]: trait.TcpStreamExt.html#tymethod.set_nonblocking"},
{"lineNum":"  538","line":"    fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()>;"},
{"lineNum":"  539","line":"}"},
{"lineNum":"  540","line":""},
{"lineNum":"  541","line":"#[doc(hidden)]"},
{"lineNum":"  542","line":"pub trait AsSock {"},
{"lineNum":"  543","line":"    fn as_sock(&self) -> Socket;"},
{"lineNum":"  544","line":"}"},
{"lineNum":"  545","line":""},
{"lineNum":"  546","line":"#[cfg(unix)]"},
{"lineNum":"  547","line":"impl<T: AsRawFd> AsSock for T {"},
{"lineNum":"  548","line":"    fn as_sock(&self) -> Socket { self.as_raw_fd() }","class":"lineCov","hits":"1","order":"1423",},
{"lineNum":"  549","line":"}"},
{"lineNum":"  550","line":"#[cfg(windows)]"},
{"lineNum":"  551","line":"impl<T: AsRawSocket> AsSock for T {"},
{"lineNum":"  552","line":"    fn as_sock(&self) -> Socket { self.as_raw_socket() }"},
{"lineNum":"  553","line":"}"},
{"lineNum":"  554","line":""},
{"lineNum":"  555","line":"cfg_if! {"},
{"lineNum":"  556","line":"    if #[cfg(any(target_os = \"macos\", target_os = \"ios\"))] {"},
{"lineNum":"  557","line":"        use libc::TCP_KEEPALIVE as KEEPALIVE_OPTION;"},
{"lineNum":"  558","line":"    } else if #[cfg(any(target_os = \"openbsd\", target_os = \"netbsd\"))] {"},
{"lineNum":"  559","line":"        use libc::SO_KEEPALIVE as KEEPALIVE_OPTION;"},
{"lineNum":"  560","line":"    } else if #[cfg(unix)] {"},
{"lineNum":"  561","line":"        use libc::TCP_KEEPIDLE as KEEPALIVE_OPTION;"},
{"lineNum":"  562","line":"    } else {"},
{"lineNum":"  563","line":"        // ..."},
{"lineNum":"  564","line":"    }"},
{"lineNum":"  565","line":"}"},
{"lineNum":"  566","line":""},
{"lineNum":"  567","line":"impl TcpStreamExt for TcpStream {"},
{"lineNum":"  568","line":"    fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {"},
{"lineNum":"  569","line":"        set_opt(self.as_sock(), v(IPPROTO_TCP), TCP_NODELAY,"},
{"lineNum":"  570","line":"               nodelay as c_int)"},
{"lineNum":"  571","line":"    }"},
{"lineNum":"  572","line":"    fn nodelay(&self) -> io::Result<bool> {"},
{"lineNum":"  573","line":"        get_opt(self.as_sock(), v(IPPROTO_TCP), TCP_NODELAY)"},
{"lineNum":"  574","line":"            .map(int2bool)"},
{"lineNum":"  575","line":"    }"},
{"lineNum":"  576","line":""},
{"lineNum":"  577","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  578","line":"    fn set_keepalive(&self, keepalive: Option<Duration>) -> io::Result<()> {"},
{"lineNum":"  579","line":"        self.set_keepalive_ms(keepalive.map(dur2ms))"},
{"lineNum":"  580","line":"    }"},
{"lineNum":"  581","line":""},
{"lineNum":"  582","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  583","line":"    fn keepalive(&self) -> io::Result<Option<Duration>> {"},
{"lineNum":"  584","line":"        self.keepalive_ms().map(|o| o.map(ms2dur))"},
{"lineNum":"  585","line":"    }"},
{"lineNum":"  586","line":""},
{"lineNum":"  587","line":"    #[cfg(unix)]"},
{"lineNum":"  588","line":"    fn set_keepalive_ms(&self, keepalive: Option<u32>) -> io::Result<()> {"},
{"lineNum":"  589","line":"        try!(set_opt(self.as_sock(), SOL_SOCKET, SO_KEEPALIVE,"},
{"lineNum":"  590","line":"                    keepalive.is_some() as c_int));"},
{"lineNum":"  591","line":"        if let Some(dur) = keepalive {"},
{"lineNum":"  592","line":"            try!(set_opt(self.as_sock(), v(IPPROTO_TCP), KEEPALIVE_OPTION,"},
{"lineNum":"  593","line":"                        (dur / 1000) as c_int));"},
{"lineNum":"  594","line":"        }"},
{"lineNum":"  595","line":"        Ok(())"},
{"lineNum":"  596","line":"    }"},
{"lineNum":"  597","line":""},
{"lineNum":"  598","line":"    #[cfg(unix)]"},
{"lineNum":"  599","line":"    fn keepalive_ms(&self) -> io::Result<Option<u32>> {"},
{"lineNum":"  600","line":"        let keepalive = try!(get_opt::<c_int>(self.as_sock(), SOL_SOCKET,"},
{"lineNum":"  601","line":"                                             SO_KEEPALIVE));"},
{"lineNum":"  602","line":"        if keepalive == 0 {"},
{"lineNum":"  603","line":"            return Ok(None)"},
{"lineNum":"  604","line":"        }"},
{"lineNum":"  605","line":"        let secs = try!(get_opt::<c_int>(self.as_sock(), v(IPPROTO_TCP),"},
{"lineNum":"  606","line":"                                        KEEPALIVE_OPTION));"},
{"lineNum":"  607","line":"        Ok(Some((secs as u32) * 1000))"},
{"lineNum":"  608","line":"    }"},
{"lineNum":"  609","line":""},
{"lineNum":"  610","line":"    #[cfg(windows)]"},
{"lineNum":"  611","line":"    fn set_keepalive_ms(&self, keepalive: Option<u32>) -> io::Result<()> {"},
{"lineNum":"  612","line":"        let ms = keepalive.unwrap_or(INFINITE);"},
{"lineNum":"  613","line":"        let ka = tcp_keepalive {"},
{"lineNum":"  614","line":"            onoff: keepalive.is_some() as c_ulong,"},
{"lineNum":"  615","line":"            keepalivetime: ms as c_ulong,"},
{"lineNum":"  616","line":"            keepaliveinterval: ms as c_ulong,"},
{"lineNum":"  617","line":"        };"},
{"lineNum":"  618","line":"        unsafe {"},
{"lineNum":"  619","line":"            ::cvt_win(WSAIoctl(self.as_sock(),"},
{"lineNum":"  620","line":"                               SIO_KEEPALIVE_VALS,"},
{"lineNum":"  621","line":"                               &ka as *const _ as *mut _,"},
{"lineNum":"  622","line":"                               mem::size_of_val(&ka) as DWORD,"},
{"lineNum":"  623","line":"                               0 as *mut _,"},
{"lineNum":"  624","line":"                               0,"},
{"lineNum":"  625","line":"                               0 as *mut _,"},
{"lineNum":"  626","line":"                               0 as *mut _,"},
{"lineNum":"  627","line":"                               None)).map(|_| ())"},
{"lineNum":"  628","line":"        }"},
{"lineNum":"  629","line":"    }"},
{"lineNum":"  630","line":""},
{"lineNum":"  631","line":"    #[cfg(windows)]"},
{"lineNum":"  632","line":"    fn keepalive_ms(&self) -> io::Result<Option<u32>> {"},
{"lineNum":"  633","line":"        let mut ka = tcp_keepalive {"},
{"lineNum":"  634","line":"            onoff: 0,"},
{"lineNum":"  635","line":"            keepalivetime: 0,"},
{"lineNum":"  636","line":"            keepaliveinterval: 0,"},
{"lineNum":"  637","line":"        };"},
{"lineNum":"  638","line":"        unsafe {"},
{"lineNum":"  639","line":"            try!(::cvt_win(WSAIoctl(self.as_sock(),"},
{"lineNum":"  640","line":"                                    SIO_KEEPALIVE_VALS,"},
{"lineNum":"  641","line":"                                    0 as *mut _,"},
{"lineNum":"  642","line":"                                    0,"},
{"lineNum":"  643","line":"                                    &mut ka as *mut _ as *mut _,"},
{"lineNum":"  644","line":"                                    mem::size_of_val(&ka) as DWORD,"},
{"lineNum":"  645","line":"                                    0 as *mut _,"},
{"lineNum":"  646","line":"                                    0 as *mut _,"},
{"lineNum":"  647","line":"                                    None)));"},
{"lineNum":"  648","line":"        }"},
{"lineNum":"  649","line":"        Ok({"},
{"lineNum":"  650","line":"            if ka.onoff == 0 {"},
{"lineNum":"  651","line":"                None"},
{"lineNum":"  652","line":"            } else {"},
{"lineNum":"  653","line":"                timeout2ms(ka.keepaliveinterval as DWORD)"},
{"lineNum":"  654","line":"            }"},
{"lineNum":"  655","line":"        })"},
{"lineNum":"  656","line":"    }"},
{"lineNum":"  657","line":""},
{"lineNum":"  658","line":"    fn set_read_timeout_ms(&self, dur: Option<u32>) -> io::Result<()> {"},
{"lineNum":"  659","line":"        set_opt(self.as_sock(), SOL_SOCKET, SO_RCVTIMEO,"},
{"lineNum":"  660","line":"               ms2timeout(dur))"},
{"lineNum":"  661","line":"    }"},
{"lineNum":"  662","line":""},
{"lineNum":"  663","line":"    fn read_timeout_ms(&self) -> io::Result<Option<u32>> {"},
{"lineNum":"  664","line":"        get_opt(self.as_sock(), SOL_SOCKET, SO_RCVTIMEO)"},
{"lineNum":"  665","line":"            .map(timeout2ms)"},
{"lineNum":"  666","line":"    }"},
{"lineNum":"  667","line":""},
{"lineNum":"  668","line":"    fn set_write_timeout_ms(&self, dur: Option<u32>) -> io::Result<()> {"},
{"lineNum":"  669","line":"        set_opt(self.as_sock(), SOL_SOCKET, SO_SNDTIMEO,"},
{"lineNum":"  670","line":"               ms2timeout(dur))"},
{"lineNum":"  671","line":"    }"},
{"lineNum":"  672","line":""},
{"lineNum":"  673","line":"    fn write_timeout_ms(&self) -> io::Result<Option<u32>> {"},
{"lineNum":"  674","line":"        get_opt(self.as_sock(), SOL_SOCKET, SO_SNDTIMEO)"},
{"lineNum":"  675","line":"            .map(timeout2ms)"},
{"lineNum":"  676","line":"    }"},
{"lineNum":"  677","line":""},
{"lineNum":"  678","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  679","line":"    fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {"},
{"lineNum":"  680","line":"        self.set_read_timeout_ms(dur.map(dur2ms))"},
{"lineNum":"  681","line":"    }"},
{"lineNum":"  682","line":""},
{"lineNum":"  683","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  684","line":"    fn read_timeout(&self) -> io::Result<Option<Duration>> {"},
{"lineNum":"  685","line":"        self.read_timeout_ms().map(|o| o.map(ms2dur))"},
{"lineNum":"  686","line":"    }"},
{"lineNum":"  687","line":""},
{"lineNum":"  688","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  689","line":"    fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {"},
{"lineNum":"  690","line":"        self.set_write_timeout_ms(dur.map(dur2ms))"},
{"lineNum":"  691","line":"    }"},
{"lineNum":"  692","line":""},
{"lineNum":"  693","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  694","line":"    fn write_timeout(&self) -> io::Result<Option<Duration>> {"},
{"lineNum":"  695","line":"        self.write_timeout_ms().map(|o| o.map(ms2dur))"},
{"lineNum":"  696","line":"    }"},
{"lineNum":"  697","line":""},
{"lineNum":"  698","line":"    fn set_ttl(&self, ttl: u32) -> io::Result<()> {"},
{"lineNum":"  699","line":"        set_opt(self.as_sock(), IPPROTO_IP, IP_TTL, ttl as c_int)"},
{"lineNum":"  700","line":"    }"},
{"lineNum":"  701","line":""},
{"lineNum":"  702","line":"    fn ttl(&self) -> io::Result<u32> {"},
{"lineNum":"  703","line":"        get_opt::<c_int>(self.as_sock(), IPPROTO_IP, IP_TTL)"},
{"lineNum":"  704","line":"            .map(|b| b as u32)"},
{"lineNum":"  705","line":"    }"},
{"lineNum":"  706","line":""},
{"lineNum":"  707","line":"    fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {"},
{"lineNum":"  708","line":"        set_opt(self.as_sock(), v(IPPROTO_IPV6), IPV6_V6ONLY, only_v6 as c_int)"},
{"lineNum":"  709","line":"    }"},
{"lineNum":"  710","line":""},
{"lineNum":"  711","line":"    fn only_v6(&self) -> io::Result<bool> {"},
{"lineNum":"  712","line":"        get_opt(self.as_sock(), v(IPPROTO_IPV6), IPV6_V6ONLY).map(int2bool)"},
{"lineNum":"  713","line":"    }"},
{"lineNum":"  714","line":""},
{"lineNum":"  715","line":"    fn connect<T: ToSocketAddrs>(&self, addr: T) -> io::Result<()> {"},
{"lineNum":"  716","line":"        do_connect(self.as_sock(), addr)"},
{"lineNum":"  717","line":"    }"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"    fn take_error(&self) -> io::Result<Option<io::Error>> {"},
{"lineNum":"  720","line":"        get_opt(self.as_sock(), SOL_SOCKET, SO_ERROR).map(int2err)"},
{"lineNum":"  721","line":"    }"},
{"lineNum":"  722","line":""},
{"lineNum":"  723","line":"    fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {"},
{"lineNum":"  724","line":"        set_nonblocking(self.as_sock(), nonblocking)"},
{"lineNum":"  725","line":"    }"},
{"lineNum":"  726","line":"}"},
{"lineNum":"  727","line":""},
{"lineNum":"  728","line":"#[cfg(unix)]"},
{"lineNum":"  729","line":"fn ms2timeout(dur: Option<u32>) -> timeval {"},
{"lineNum":"  730","line":"    // TODO: be more rigorous"},
{"lineNum":"  731","line":"    match dur {"},
{"lineNum":"  732","line":"        Some(d) => timeval {"},
{"lineNum":"  733","line":"            tv_sec: (d / 1000) as time_t,"},
{"lineNum":"  734","line":"            tv_usec: (d % 1000) as suseconds_t,"},
{"lineNum":"  735","line":"        },"},
{"lineNum":"  736","line":"        None => timeval { tv_sec: 0, tv_usec: 0 },"},
{"lineNum":"  737","line":"    }"},
{"lineNum":"  738","line":"}"},
{"lineNum":"  739","line":""},
{"lineNum":"  740","line":"#[cfg(unix)]"},
{"lineNum":"  741","line":"fn timeout2ms(dur: timeval) -> Option<u32> {"},
{"lineNum":"  742","line":"    if dur.tv_sec == 0 && dur.tv_usec == 0 {"},
{"lineNum":"  743","line":"        None"},
{"lineNum":"  744","line":"    } else {"},
{"lineNum":"  745","line":"        Some(dur.tv_sec as u32 * 1000 + dur.tv_usec as u32 / 1000)"},
{"lineNum":"  746","line":"    }"},
{"lineNum":"  747","line":"}"},
{"lineNum":"  748","line":""},
{"lineNum":"  749","line":"#[cfg(windows)]"},
{"lineNum":"  750","line":"fn ms2timeout(dur: Option<u32>) -> DWORD {"},
{"lineNum":"  751","line":"    dur.unwrap_or(0)"},
{"lineNum":"  752","line":"}"},
{"lineNum":"  753","line":""},
{"lineNum":"  754","line":"#[cfg(windows)]"},
{"lineNum":"  755","line":"fn timeout2ms(dur: DWORD) -> Option<u32> {"},
{"lineNum":"  756","line":"    if dur == 0 {"},
{"lineNum":"  757","line":"        None"},
{"lineNum":"  758","line":"    } else {"},
{"lineNum":"  759","line":"        Some(dur)"},
{"lineNum":"  760","line":"    }"},
{"lineNum":"  761","line":"}"},
{"lineNum":"  762","line":""},
{"lineNum":"  763","line":"#[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  764","line":"fn ms2dur(ms: u32) -> Duration {"},
{"lineNum":"  765","line":"    Duration::new((ms as u64) / 1000, (ms as u32) % 1000 * 1_000_000)"},
{"lineNum":"  766","line":"}"},
{"lineNum":"  767","line":""},
{"lineNum":"  768","line":"#[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  769","line":"fn dur2ms(dur: Duration) -> u32 {"},
{"lineNum":"  770","line":"    (dur.as_secs() as u32 * 1000) + (dur.subsec_nanos() / 1_000_000)"},
{"lineNum":"  771","line":"}"},
{"lineNum":"  772","line":""},
{"lineNum":"  773","line":"fn int2bool(n: c_int) -> bool {"},
{"lineNum":"  774","line":"    if n == 0 {false} else {true}"},
{"lineNum":"  775","line":"}"},
{"lineNum":"  776","line":""},
{"lineNum":"  777","line":"fn int2err(n: c_int) -> Option<io::Error> {"},
{"lineNum":"  778","line":"    if n == 0 {"},
{"lineNum":"  779","line":"        None"},
{"lineNum":"  780","line":"    } else {"},
{"lineNum":"  781","line":"        Some(io::Error::from_raw_os_error(n as i32))"},
{"lineNum":"  782","line":"    }"},
{"lineNum":"  783","line":"}"},
{"lineNum":"  784","line":""},
{"lineNum":"  785","line":"impl UdpSocketExt for UdpSocket {"},
{"lineNum":"  786","line":"    fn set_broadcast(&self, broadcast: bool) -> io::Result<()> {"},
{"lineNum":"  787","line":"        set_opt(self.as_sock(), SOL_SOCKET, SO_BROADCAST,"},
{"lineNum":"  788","line":"               broadcast as c_int)"},
{"lineNum":"  789","line":"    }"},
{"lineNum":"  790","line":"    fn broadcast(&self) -> io::Result<bool> {"},
{"lineNum":"  791","line":"        get_opt(self.as_sock(), SOL_SOCKET, SO_BROADCAST)"},
{"lineNum":"  792","line":"            .map(int2bool)"},
{"lineNum":"  793","line":"    }"},
{"lineNum":"  794","line":"    fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {"},
{"lineNum":"  795","line":"        set_opt(self.as_sock(), IPPROTO_IP, IP_MULTICAST_LOOP,"},
{"lineNum":"  796","line":"               multicast_loop_v4 as c_int)"},
{"lineNum":"  797","line":"    }"},
{"lineNum":"  798","line":"    fn multicast_loop_v4(&self) -> io::Result<bool> {"},
{"lineNum":"  799","line":"        get_opt(self.as_sock(), IPPROTO_IP, IP_MULTICAST_LOOP)"},
{"lineNum":"  800","line":"            .map(int2bool)"},
{"lineNum":"  801","line":"    }"},
{"lineNum":"  802","line":"    fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {"},
{"lineNum":"  803","line":"        set_opt(self.as_sock(), IPPROTO_IP, IP_MULTICAST_TTL,"},
{"lineNum":"  804","line":"               multicast_ttl_v4 as c_int)"},
{"lineNum":"  805","line":"    }"},
{"lineNum":"  806","line":"    fn multicast_ttl_v4(&self) -> io::Result<u32> {"},
{"lineNum":"  807","line":"        get_opt::<c_int>(self.as_sock(), IPPROTO_IP, IP_MULTICAST_TTL)"},
{"lineNum":"  808","line":"            .map(|b| b as u32)"},
{"lineNum":"  809","line":"    }"},
{"lineNum":"  810","line":"    fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {"},
{"lineNum":"  811","line":"        set_opt(self.as_sock(), v(IPPROTO_IPV6), IPV6_MULTICAST_LOOP,"},
{"lineNum":"  812","line":"               multicast_loop_v6 as c_int)"},
{"lineNum":"  813","line":"    }"},
{"lineNum":"  814","line":"    fn multicast_loop_v6(&self) -> io::Result<bool> {"},
{"lineNum":"  815","line":"        get_opt(self.as_sock(), v(IPPROTO_IPV6), IPV6_MULTICAST_LOOP)"},
{"lineNum":"  816","line":"            .map(int2bool)"},
{"lineNum":"  817","line":"    }"},
{"lineNum":"  818","line":""},
{"lineNum":"  819","line":"    fn set_ttl(&self, ttl: u32) -> io::Result<()> {"},
{"lineNum":"  820","line":"        set_opt(self.as_sock(), IPPROTO_IP, IP_TTL, ttl as c_int)"},
{"lineNum":"  821","line":"    }"},
{"lineNum":"  822","line":""},
{"lineNum":"  823","line":"    fn ttl(&self) -> io::Result<u32> {"},
{"lineNum":"  824","line":"        get_opt::<c_int>(self.as_sock(), IPPROTO_IP, IP_TTL)"},
{"lineNum":"  825","line":"            .map(|b| b as u32)"},
{"lineNum":"  826","line":"    }"},
{"lineNum":"  827","line":""},
{"lineNum":"  828","line":"    fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {"},
{"lineNum":"  829","line":"        set_opt(self.as_sock(), v(IPPROTO_IPV6), IPV6_V6ONLY, only_v6 as c_int)"},
{"lineNum":"  830","line":"    }"},
{"lineNum":"  831","line":""},
{"lineNum":"  832","line":"    fn only_v6(&self) -> io::Result<bool> {"},
{"lineNum":"  833","line":"        get_opt(self.as_sock(), v(IPPROTO_IPV6), IPV6_V6ONLY).map(int2bool)"},
{"lineNum":"  834","line":"    }"},
{"lineNum":"  835","line":""},
{"lineNum":"  836","line":"    fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr)"},
{"lineNum":"  837","line":"                         -> io::Result<()> {"},
{"lineNum":"  838","line":"        let mreq = ip_mreq {"},
{"lineNum":"  839","line":"            imr_multiaddr: ip2in_addr(multiaddr),"},
{"lineNum":"  840","line":"            imr_interface: ip2in_addr(interface),"},
{"lineNum":"  841","line":"        };"},
{"lineNum":"  842","line":"        set_opt(self.as_sock(), IPPROTO_IP, IP_ADD_MEMBERSHIP, mreq)"},
{"lineNum":"  843","line":"    }"},
{"lineNum":"  844","line":""},
{"lineNum":"  845","line":"    fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32)"},
{"lineNum":"  846","line":"                         -> io::Result<()> {"},
{"lineNum":"  847","line":"        let mreq = ipv6_mreq {"},
{"lineNum":"  848","line":"            ipv6mr_multiaddr: ip2in6_addr(multiaddr),"},
{"lineNum":"  849","line":"            ipv6mr_interface: to_ipv6mr_interface(interface),"},
{"lineNum":"  850","line":"        };"},
{"lineNum":"  851","line":"        set_opt(self.as_sock(), v(IPPROTO_IPV6), IPV6_ADD_MEMBERSHIP,"},
{"lineNum":"  852","line":"               mreq)"},
{"lineNum":"  853","line":"    }"},
{"lineNum":"  854","line":""},
{"lineNum":"  855","line":"    fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr)"},
{"lineNum":"  856","line":"                          -> io::Result<()> {"},
{"lineNum":"  857","line":"        let mreq = ip_mreq {"},
{"lineNum":"  858","line":"            imr_multiaddr: ip2in_addr(multiaddr),"},
{"lineNum":"  859","line":"            imr_interface: ip2in_addr(interface),"},
{"lineNum":"  860","line":"        };"},
{"lineNum":"  861","line":"        set_opt(self.as_sock(), IPPROTO_IP, IP_DROP_MEMBERSHIP, mreq)"},
{"lineNum":"  862","line":"    }"},
{"lineNum":"  863","line":""},
{"lineNum":"  864","line":"    fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32)"},
{"lineNum":"  865","line":"                          -> io::Result<()> {"},
{"lineNum":"  866","line":"        let mreq = ipv6_mreq {"},
{"lineNum":"  867","line":"            ipv6mr_multiaddr: ip2in6_addr(multiaddr),"},
{"lineNum":"  868","line":"            ipv6mr_interface: to_ipv6mr_interface(interface),"},
{"lineNum":"  869","line":"        };"},
{"lineNum":"  870","line":"        set_opt(self.as_sock(), v(IPPROTO_IPV6), IPV6_DROP_MEMBERSHIP,"},
{"lineNum":"  871","line":"               mreq)"},
{"lineNum":"  872","line":"    }"},
{"lineNum":"  873","line":""},
{"lineNum":"  874","line":"    fn set_read_timeout_ms(&self, dur: Option<u32>) -> io::Result<()> {"},
{"lineNum":"  875","line":"        set_opt(self.as_sock(), SOL_SOCKET, SO_RCVTIMEO,"},
{"lineNum":"  876","line":"               ms2timeout(dur))"},
{"lineNum":"  877","line":"    }"},
{"lineNum":"  878","line":""},
{"lineNum":"  879","line":"    fn read_timeout_ms(&self) -> io::Result<Option<u32>> {"},
{"lineNum":"  880","line":"        get_opt(self.as_sock(), SOL_SOCKET, SO_RCVTIMEO)"},
{"lineNum":"  881","line":"            .map(timeout2ms)"},
{"lineNum":"  882","line":"    }"},
{"lineNum":"  883","line":""},
{"lineNum":"  884","line":"    fn set_write_timeout_ms(&self, dur: Option<u32>) -> io::Result<()> {"},
{"lineNum":"  885","line":"        set_opt(self.as_sock(), SOL_SOCKET, SO_SNDTIMEO,"},
{"lineNum":"  886","line":"               ms2timeout(dur))"},
{"lineNum":"  887","line":"    }"},
{"lineNum":"  888","line":""},
{"lineNum":"  889","line":"    fn write_timeout_ms(&self) -> io::Result<Option<u32>> {"},
{"lineNum":"  890","line":"        get_opt(self.as_sock(), SOL_SOCKET, SO_SNDTIMEO)"},
{"lineNum":"  891","line":"            .map(timeout2ms)"},
{"lineNum":"  892","line":"    }"},
{"lineNum":"  893","line":""},
{"lineNum":"  894","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  895","line":"    fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {"},
{"lineNum":"  896","line":"        self.set_read_timeout_ms(dur.map(dur2ms))"},
{"lineNum":"  897","line":"    }"},
{"lineNum":"  898","line":""},
{"lineNum":"  899","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  900","line":"    fn read_timeout(&self) -> io::Result<Option<Duration>> {"},
{"lineNum":"  901","line":"        self.read_timeout_ms().map(|o| o.map(ms2dur))"},
{"lineNum":"  902","line":"    }"},
{"lineNum":"  903","line":""},
{"lineNum":"  904","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  905","line":"    fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {"},
{"lineNum":"  906","line":"        self.set_write_timeout_ms(dur.map(dur2ms))"},
{"lineNum":"  907","line":"    }"},
{"lineNum":"  908","line":""},
{"lineNum":"  909","line":"    #[cfg(any(feature = \"nightly\", feature = \"duration\"))]"},
{"lineNum":"  910","line":"    fn write_timeout(&self) -> io::Result<Option<Duration>> {"},
{"lineNum":"  911","line":"        self.write_timeout_ms().map(|o| o.map(ms2dur))"},
{"lineNum":"  912","line":"    }"},
{"lineNum":"  913","line":""},
{"lineNum":"  914","line":"    fn take_error(&self) -> io::Result<Option<io::Error>> {"},
{"lineNum":"  915","line":"        get_opt(self.as_sock(), SOL_SOCKET, SO_ERROR).map(int2err)"},
{"lineNum":"  916","line":"    }"},
{"lineNum":"  917","line":""},
{"lineNum":"  918","line":"    fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {"},
{"lineNum":"  919","line":"        do_connect(self.as_sock(), addr)"},
{"lineNum":"  920","line":"    }"},
{"lineNum":"  921","line":""},
{"lineNum":"  922","line":"    #[cfg(unix)]"},
{"lineNum":"  923","line":"    fn send(&self, buf: &[u8]) -> io::Result<usize> {"},
{"lineNum":"  924","line":"        unsafe {"},
{"lineNum":"  925","line":"            ::cvt(send(self.as_sock(), buf.as_ptr() as *const _, buf.len(), 0)).map(|n| n as usize)"},
{"lineNum":"  926","line":"        }"},
{"lineNum":"  927","line":"    }"},
{"lineNum":"  928","line":""},
{"lineNum":"  929","line":"    #[cfg(windows)]"},
{"lineNum":"  930","line":"    fn send(&self, buf: &[u8]) -> io::Result<usize> {"},
{"lineNum":"  931","line":"        let len = ::std::cmp::min(buf.len(), c_int::max_value() as usize);"},
{"lineNum":"  932","line":"        let buf = &buf[..len];"},
{"lineNum":"  933","line":"        unsafe {"},
{"lineNum":"  934","line":"            ::cvt(send(self.as_sock(), buf.as_ptr() as *const _, len as c_int, 0))"},
{"lineNum":"  935","line":"                .map(|n| n as usize)"},
{"lineNum":"  936","line":"        }"},
{"lineNum":"  937","line":"    }"},
{"lineNum":"  938","line":""},
{"lineNum":"  939","line":"    #[cfg(unix)]"},
{"lineNum":"  940","line":"    fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {"},
{"lineNum":"  941","line":"        unsafe {"},
{"lineNum":"  942","line":"            ::cvt(recv(self.as_sock(), buf.as_mut_ptr() as *mut _, buf.len(), 0))"},
{"lineNum":"  943","line":"                .map(|n| n as usize)"},
{"lineNum":"  944","line":"        }"},
{"lineNum":"  945","line":"    }"},
{"lineNum":"  946","line":""},
{"lineNum":"  947","line":"    #[cfg(windows)]"},
{"lineNum":"  948","line":"    fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {"},
{"lineNum":"  949","line":"        let len = ::std::cmp::min(buf.len(), c_int::max_value() as usize);"},
{"lineNum":"  950","line":"        let buf = &mut buf[..len];"},
{"lineNum":"  951","line":"        unsafe {"},
{"lineNum":"  952","line":"            ::cvt(recv(self.as_sock(), buf.as_mut_ptr() as *mut _, buf.len() as c_int, 0))"},
{"lineNum":"  953","line":"                .map(|n| n as usize)"},
{"lineNum":"  954","line":"        }"},
{"lineNum":"  955","line":"    }"},
{"lineNum":"  956","line":""},
{"lineNum":"  957","line":"    fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {"},
{"lineNum":"  958","line":"        set_nonblocking(self.as_sock(), nonblocking)"},
{"lineNum":"  959","line":"    }"},
{"lineNum":"  960","line":"}"},
{"lineNum":"  961","line":""},
{"lineNum":"  962","line":"fn do_connect<A: ToSocketAddrs>(sock: Socket, addr: A) -> io::Result<()> {"},
{"lineNum":"  963","line":"    let err = io::Error::new(io::ErrorKind::Other,"},
{"lineNum":"  964","line":"                             \"no socket addresses resolved\");"},
{"lineNum":"  965","line":"    let addrs = try!(addr.to_socket_addrs());"},
{"lineNum":"  966","line":"    let sys = sys::Socket::from_inner(sock);"},
{"lineNum":"  967","line":"    let sock = socket::Socket::from_inner(sys);"},
{"lineNum":"  968","line":"    let ret = addrs.fold(Err(err), |prev, addr| {"},
{"lineNum":"  969","line":"        prev.or_else(|_| sock.connect(&addr))"},
{"lineNum":"  970","line":"    });"},
{"lineNum":"  971","line":"    mem::forget(sock);"},
{"lineNum":"  972","line":"    return ret"},
{"lineNum":"  973","line":"}"},
{"lineNum":"  974","line":""},
{"lineNum":"  975","line":"#[cfg(unix)]"},
{"lineNum":"  976","line":"fn set_nonblocking(sock: Socket, nonblocking: bool) -> io::Result<()> {"},
{"lineNum":"  977","line":"    let mut nonblocking = nonblocking as c_ulong;"},
{"lineNum":"  978","line":"    ::cvt(unsafe {"},
{"lineNum":"  979","line":"        ioctl(sock, FIONBIO, &mut nonblocking)"},
{"lineNum":"  980","line":"    }).map(|_| ())"},
{"lineNum":"  981","line":"}"},
{"lineNum":"  982","line":""},
{"lineNum":"  983","line":"#[cfg(windows)]"},
{"lineNum":"  984","line":"fn set_nonblocking(sock: Socket, nonblocking: bool) -> io::Result<()> {"},
{"lineNum":"  985","line":"    let mut nonblocking = nonblocking as c_ulong;"},
{"lineNum":"  986","line":"    ::cvt(unsafe {"},
{"lineNum":"  987","line":"        ioctlsocket(sock, FIONBIO as c_int, &mut nonblocking)"},
{"lineNum":"  988","line":"    }).map(|_| ())"},
{"lineNum":"  989","line":"}"},
{"lineNum":"  990","line":""},
{"lineNum":"  991","line":"#[cfg(unix)]"},
{"lineNum":"  992","line":"fn ip2in_addr(ip: &Ipv4Addr) -> in_addr {"},
{"lineNum":"  993","line":"    let oct = ip.octets();"},
{"lineNum":"  994","line":"    in_addr {"},
{"lineNum":"  995","line":"        s_addr: ::hton(((oct[0] as u32) << 24) |"},
{"lineNum":"  996","line":"                       ((oct[1] as u32) << 16) |"},
{"lineNum":"  997","line":"                       ((oct[2] as u32) <<  8) |"},
{"lineNum":"  998","line":"                       ((oct[3] as u32) <<  0)),"},
{"lineNum":"  999","line":"    }"},
{"lineNum":" 1000","line":"}"},
{"lineNum":" 1001","line":""},
{"lineNum":" 1002","line":"#[cfg(windows)]"},
{"lineNum":" 1003","line":"fn ip2in_addr(ip: &Ipv4Addr) -> in_addr {"},
{"lineNum":" 1004","line":"    let oct = ip.octets();"},
{"lineNum":" 1005","line":"    in_addr {"},
{"lineNum":" 1006","line":"        S_un: ::hton(((oct[0] as u32) << 24) |"},
{"lineNum":" 1007","line":"                     ((oct[1] as u32) << 16) |"},
{"lineNum":" 1008","line":"                     ((oct[2] as u32) <<  8) |"},
{"lineNum":" 1009","line":"                     ((oct[3] as u32) <<  0)),"},
{"lineNum":" 1010","line":"    }"},
{"lineNum":" 1011","line":"}"},
{"lineNum":" 1012","line":""},
{"lineNum":" 1013","line":"#[cfg(target_os = \"android\")]"},
{"lineNum":" 1014","line":"fn to_ipv6mr_interface(value: u32) -> c_int {"},
{"lineNum":" 1015","line":"    value as c_int"},
{"lineNum":" 1016","line":"}"},
{"lineNum":" 1017","line":""},
{"lineNum":" 1018","line":"#[cfg(not(target_os = \"android\"))]"},
{"lineNum":" 1019","line":"fn to_ipv6mr_interface(value: u32) -> c_uint {"},
{"lineNum":" 1020","line":"    value as c_uint"},
{"lineNum":" 1021","line":"}"},
{"lineNum":" 1022","line":""},
{"lineNum":" 1023","line":"fn ip2in6_addr(ip: &Ipv6Addr) -> in6_addr {"},
{"lineNum":" 1024","line":"    let mut ret: in6_addr = unsafe { mem::zeroed() };"},
{"lineNum":" 1025","line":"    let seg = ip.segments();"},
{"lineNum":" 1026","line":"    ret.s6_addr = ["},
{"lineNum":" 1027","line":"        (seg[0] >> 8) as u8,"},
{"lineNum":" 1028","line":"        (seg[0] >> 0) as u8,"},
{"lineNum":" 1029","line":"        (seg[1] >> 8) as u8,"},
{"lineNum":" 1030","line":"        (seg[1] >> 0) as u8,"},
{"lineNum":" 1031","line":"        (seg[2] >> 8) as u8,"},
{"lineNum":" 1032","line":"        (seg[2] >> 0) as u8,"},
{"lineNum":" 1033","line":"        (seg[3] >> 8) as u8,"},
{"lineNum":" 1034","line":"        (seg[3] >> 0) as u8,"},
{"lineNum":" 1035","line":"        (seg[4] >> 8) as u8,"},
{"lineNum":" 1036","line":"        (seg[4] >> 0) as u8,"},
{"lineNum":" 1037","line":"        (seg[5] >> 8) as u8,"},
{"lineNum":" 1038","line":"        (seg[5] >> 0) as u8,"},
{"lineNum":" 1039","line":"        (seg[6] >> 8) as u8,"},
{"lineNum":" 1040","line":"        (seg[6] >> 0) as u8,"},
{"lineNum":" 1041","line":"        (seg[7] >> 8) as u8,"},
{"lineNum":" 1042","line":"        (seg[7] >> 0) as u8,"},
{"lineNum":" 1043","line":"    ];"},
{"lineNum":" 1044","line":"    return ret"},
{"lineNum":" 1045","line":"}"},
{"lineNum":" 1046","line":""},
{"lineNum":" 1047","line":"impl TcpListenerExt for TcpListener {"},
{"lineNum":" 1048","line":"    fn set_ttl(&self, ttl: u32) -> io::Result<()> {"},
{"lineNum":" 1049","line":"        set_opt(self.as_sock(), IPPROTO_IP, IP_TTL, ttl as c_int)"},
{"lineNum":" 1050","line":"    }"},
{"lineNum":" 1051","line":""},
{"lineNum":" 1052","line":"    fn ttl(&self) -> io::Result<u32> {"},
{"lineNum":" 1053","line":"        get_opt::<c_int>(self.as_sock(), IPPROTO_IP, IP_TTL)"},
{"lineNum":" 1054","line":"            .map(|b| b as u32)"},
{"lineNum":" 1055","line":"    }"},
{"lineNum":" 1056","line":""},
{"lineNum":" 1057","line":"    fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {"},
{"lineNum":" 1058","line":"        set_opt(self.as_sock(), v(IPPROTO_IPV6), IPV6_V6ONLY, only_v6 as c_int)"},
{"lineNum":" 1059","line":"    }"},
{"lineNum":" 1060","line":""},
{"lineNum":" 1061","line":"    fn only_v6(&self) -> io::Result<bool> {"},
{"lineNum":" 1062","line":"        get_opt(self.as_sock(), v(IPPROTO_IPV6), IPV6_V6ONLY).map(int2bool)"},
{"lineNum":" 1063","line":"    }"},
{"lineNum":" 1064","line":""},
{"lineNum":" 1065","line":"    fn take_error(&self) -> io::Result<Option<io::Error>> {"},
{"lineNum":" 1066","line":"        get_opt(self.as_sock(), SOL_SOCKET, SO_ERROR).map(int2err)"},
{"lineNum":" 1067","line":"    }"},
{"lineNum":" 1068","line":""},
{"lineNum":" 1069","line":"    fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {"},
{"lineNum":" 1070","line":"        set_nonblocking(self.as_sock(), nonblocking)"},
{"lineNum":" 1071","line":"    }"},
{"lineNum":" 1072","line":"}"},
{"lineNum":" 1073","line":""},
{"lineNum":" 1074","line":"impl TcpBuilder {"},
{"lineNum":" 1075","line":"    /// Sets the value for the `IP_TTL` option on this socket."},
{"lineNum":" 1076","line":"    ///"},
{"lineNum":" 1077","line":"    /// This is the same as [`TcpStreamExt::set_ttl`][other]."},
{"lineNum":" 1078","line":"    ///"},
{"lineNum":" 1079","line":"    /// [other]: trait.TcpStreamExt.html#tymethod.set_ttl"},
{"lineNum":" 1080","line":"    pub fn ttl(&self, ttl: u32) -> io::Result<&Self> {"},
{"lineNum":" 1081","line":"        set_opt(self.as_sock(), IPPROTO_IP, IP_TTL, ttl as c_int)"},
{"lineNum":" 1082","line":"            .map(|()| self)"},
{"lineNum":" 1083","line":"    }"},
{"lineNum":" 1084","line":""},
{"lineNum":" 1085","line":"    /// Sets the value for the `IPV6_V6ONLY` option on this socket."},
{"lineNum":" 1086","line":"    ///"},
{"lineNum":" 1087","line":"    /// This is the same as [`TcpStreamExt::set_only_v6`][other]."},
{"lineNum":" 1088","line":"    ///"},
{"lineNum":" 1089","line":"    /// [other]: trait.TcpStreamExt.html#tymethod.set_only_v6"},
{"lineNum":" 1090","line":"    pub fn only_v6(&self, only_v6: bool) -> io::Result<&Self> {"},
{"lineNum":" 1091","line":"        set_opt(self.as_sock(), v(IPPROTO_IPV6), IPV6_V6ONLY, only_v6 as c_int)"},
{"lineNum":" 1092","line":"            .map(|()| self)"},
{"lineNum":" 1093","line":"    }"},
{"lineNum":" 1094","line":""},
{"lineNum":" 1095","line":"    /// Set value for the `SO_REUSEADDR` option on this socket."},
{"lineNum":" 1096","line":"    ///"},
{"lineNum":" 1097","line":"    /// This indicates that futher calls to `bind` may allow reuse of local"},
{"lineNum":" 1098","line":"    /// addresses. For IPv4 sockets this means that a socket may bind even when"},
{"lineNum":" 1099","line":"    /// there\'s a socket already listening on this port."},
{"lineNum":" 1100","line":"    pub fn reuse_address(&self, reuse: bool) -> io::Result<&Self> {","class":"lineCov","hits":"1","order":"1424",},
{"lineNum":" 1101","line":"        set_opt(self.as_sock(), SOL_SOCKET, SO_REUSEADDR,","class":"lineCov","hits":"1","order":"1425",},
{"lineNum":" 1102","line":"               reuse as c_int).map(|()| self)","class":"lineCov","hits":"1","order":"1426",},
{"lineNum":" 1103","line":"    }","class":"lineCov","hits":"1","order":"1427",},
{"lineNum":" 1104","line":""},
{"lineNum":" 1105","line":"    /// Get the value of the `SO_ERROR` option on this socket."},
{"lineNum":" 1106","line":"    ///"},
{"lineNum":" 1107","line":"    /// This will retrieve the stored error in the underlying socket, clearing"},
{"lineNum":" 1108","line":"    /// the field in the process. This can be useful for checking errors between"},
{"lineNum":" 1109","line":"    /// calls."},
{"lineNum":" 1110","line":"    pub fn take_error(&self) -> io::Result<Option<io::Error>> {"},
{"lineNum":" 1111","line":"        get_opt(self.as_sock(), SOL_SOCKET, SO_ERROR).map(int2err)"},
{"lineNum":" 1112","line":"    }"},
{"lineNum":" 1113","line":"}"},
{"lineNum":" 1114","line":""},
{"lineNum":" 1115","line":"impl UdpBuilder {"},
{"lineNum":" 1116","line":"    /// Sets the value for the `IP_TTL` option on this socket."},
{"lineNum":" 1117","line":"    ///"},
{"lineNum":" 1118","line":"    /// This is the same as [`TcpStreamExt::set_ttl`][other]."},
{"lineNum":" 1119","line":"    ///"},
{"lineNum":" 1120","line":"    /// [other]: trait.TcpStreamExt.html#tymethod.set_ttl"},
{"lineNum":" 1121","line":"    pub fn ttl(&self, ttl: u32) -> io::Result<&Self> {"},
{"lineNum":" 1122","line":"        set_opt(self.as_sock(), IPPROTO_IP, IP_TTL, ttl as c_int)"},
{"lineNum":" 1123","line":"            .map(|()| self)"},
{"lineNum":" 1124","line":"    }"},
{"lineNum":" 1125","line":""},
{"lineNum":" 1126","line":"    /// Sets the value for the `IPV6_V6ONLY` option on this socket."},
{"lineNum":" 1127","line":"    ///"},
{"lineNum":" 1128","line":"    /// This is the same as [`TcpStream::only_v6`][other]."},
{"lineNum":" 1129","line":"    ///"},
{"lineNum":" 1130","line":"    /// [other]: struct.TcpBuilder.html#method.only_v6"},
{"lineNum":" 1131","line":"    pub fn only_v6(&self, only_v6: bool) -> io::Result<&Self> {"},
{"lineNum":" 1132","line":"        set_opt(self.as_sock(), v(IPPROTO_IPV6), IPV6_V6ONLY, only_v6 as c_int)"},
{"lineNum":" 1133","line":"            .map(|()| self)"},
{"lineNum":" 1134","line":"    }"},
{"lineNum":" 1135","line":""},
{"lineNum":" 1136","line":"    /// Set value for the `SO_REUSEADDR` option on this socket."},
{"lineNum":" 1137","line":"    ///"},
{"lineNum":" 1138","line":"    /// This is the same as [`TcpBuilder::reuse_address`][other]."},
{"lineNum":" 1139","line":"    ///"},
{"lineNum":" 1140","line":"    /// [other]: struct.TcpBuilder.html#method.reuse_address"},
{"lineNum":" 1141","line":"    pub fn reuse_address(&self, reuse: bool) -> io::Result<&Self> {"},
{"lineNum":" 1142","line":"        set_opt(self.as_sock(), SOL_SOCKET, SO_REUSEADDR,"},
{"lineNum":" 1143","line":"               reuse as c_int).map(|()| self)"},
{"lineNum":" 1144","line":"    }"},
{"lineNum":" 1145","line":""},
{"lineNum":" 1146","line":"    /// Get the value of the `SO_ERROR` option on this socket."},
{"lineNum":" 1147","line":"    ///"},
{"lineNum":" 1148","line":"    /// This will retrieve the stored error in the underlying socket, clearing"},
{"lineNum":" 1149","line":"    /// the field in the process. This can be useful for checking errors between"},
{"lineNum":" 1150","line":"    /// calls."},
{"lineNum":" 1151","line":"    pub fn take_error(&self) -> io::Result<Option<io::Error>> {"},
{"lineNum":" 1152","line":"        get_opt(self.as_sock(), SOL_SOCKET, SO_ERROR).map(int2err)"},
{"lineNum":" 1153","line":"    }"},
{"lineNum":" 1154","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test_server-9ef2987148640087", "date" : "2016-02-17 13:22:50", "instrumented" : 12, "covered" : 11,};
var merged_data = [];
