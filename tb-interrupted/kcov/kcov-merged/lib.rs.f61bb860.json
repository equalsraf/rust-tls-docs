var data = {lines:[
{"lineNum":"    1","line":"use std::{fmt, mem, usize};"},
{"lineNum":"    2","line":"use std::iter::IntoIterator;"},
{"lineNum":"    3","line":"use std::ops;"},
{"lineNum":"    4","line":"use std::marker::PhantomData;"},
{"lineNum":"    5","line":"","class":"lineCov","hits":"1","order":"1378",},
{"lineNum":"    6","line":"/// A preallocated chunk of memory for storing objects of the same type."},
{"lineNum":"    7","line":"pub struct Slab<T, I: Index> {"},
{"lineNum":"    8","line":"    // Chunk of memory"},
{"lineNum":"    9","line":"    entries: Vec<Entry<T>>,"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"    // Number of Filled elements currently in the slab"},
{"lineNum":"   12","line":"    len: usize,"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"    // The index offset"},
{"lineNum":"   15","line":"    offset: usize,"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"    // Offset of the next available slot in the slab. Set to the slab\'s"},
{"lineNum":"   18","line":"    // capacity when the slab is full."},
{"lineNum":"   19","line":"    next: usize,"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"    _marker: PhantomData<I>,"},
{"lineNum":"   22","line":"}"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"enum Entry<T> {"},
{"lineNum":"   25","line":"    Empty(usize),"},
{"lineNum":"   26","line":"    Filled(T),"},
{"lineNum":"   27","line":"}"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"// Need this for Rust 1.0 compatibility"},
{"lineNum":"   30","line":"// See: https://github.com/rust-lang/rust/issues/15609"},
{"lineNum":"   31","line":"impl<T> Entry<T> {"},
{"lineNum":"   32","line":"    #[inline]"},
{"lineNum":"   33","line":"    fn as_mut(&mut self) -> Option<&mut T> {","class":"lineNoCov","hits":"0",},
{"lineNum":"   34","line":"        match *self {","class":"lineNoCov","hits":"0",},
{"lineNum":"   35","line":"            Entry::Filled(ref mut val) => Some(val),","class":"lineNoCov","hits":"0",},
{"lineNum":"   36","line":"            Entry::Empty(_) => None,"},
{"lineNum":"   37","line":"        }"},
{"lineNum":"   38","line":"    }"},
{"lineNum":"   39","line":"}"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"/// Slab can be indexed by any type implementing `Index` trait."},
{"lineNum":"   42","line":"pub trait Index {"},
{"lineNum":"   43","line":"    fn from_usize(i: usize) -> Self;"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"    fn as_usize(&self) -> usize;"},
{"lineNum":"   46","line":"}"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"impl Index for usize {"},
{"lineNum":"   49","line":"    fn from_usize(i: usize) -> usize {"},
{"lineNum":"   50","line":"        i"},
{"lineNum":"   51","line":"    }"},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"    fn as_usize(&self) -> usize {"},
{"lineNum":"   54","line":"        *self"},
{"lineNum":"   55","line":"    }"},
{"lineNum":"   56","line":"}"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"unsafe impl<T, I : Index> Send for Slab<T, I> where T: Send {}"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"macro_rules! some {"},
{"lineNum":"   61","line":"    ($expr:expr) => (match $expr {"},
{"lineNum":"   62","line":"        Some(val) => val,","class":"lineNoCov","hits":"0",},
{"lineNum":"   63","line":"        None => return None,","class":"lineNoCov","hits":"0",},
{"lineNum":"   64","line":"    })"},
{"lineNum":"   65","line":"}"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"impl<T, I: Index> Slab<T, I> {"},
{"lineNum":"   68","line":"    pub fn new(capacity: usize) -> Slab<T, I> {","class":"lineCov","hits":"1","order":"1379",},
{"lineNum":"   69","line":"        Slab::new_starting_at(I::from_usize(0), capacity)","class":"lineCov","hits":"1","order":"1380",},
{"lineNum":"   70","line":"    }"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"    pub fn new_starting_at(offset: I, capacity: usize) -> Slab<T, I> {","class":"lineCov","hits":"1","order":"1381",},
{"lineNum":"   73","line":"        assert!(capacity <= usize::MAX, \"capacity too large\");","class":"lineCov","hits":"1","order":"1382",},
{"lineNum":"   74","line":"        let entries = (1..capacity+1)","class":"lineCov","hits":"1","order":"1383",},
{"lineNum":"   75","line":"            .map(Entry::Empty)"},
{"lineNum":"   76","line":"            .collect::<Vec<_>>();"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"        Slab {","class":"lineCov","hits":"1","order":"1384",},
{"lineNum":"   79","line":"            entries: entries,"},
{"lineNum":"   80","line":"            next: 0,","class":"lineCov","hits":"1","order":"1385",},
{"lineNum":"   81","line":"            len: 0,","class":"lineCov","hits":"1","order":"1386",},
{"lineNum":"   82","line":"            offset: offset.as_usize(),","class":"lineCov","hits":"1","order":"1387",},
{"lineNum":"   83","line":"            _marker: PhantomData,"},
{"lineNum":"   84","line":"        }"},
{"lineNum":"   85","line":"    }"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"    #[inline]"},
{"lineNum":"   88","line":"    pub fn count(&self) -> usize {","class":"lineCov","hits":"1","order":"1388",},
{"lineNum":"   89","line":"        self.len","class":"lineCov","hits":"1","order":"1389",},
{"lineNum":"   90","line":"    }"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"    #[inline]"},
{"lineNum":"   93","line":"    pub fn is_empty(&self) -> bool {","class":"lineCov","hits":"1","order":"1390",},
{"lineNum":"   94","line":"        self.len == 0","class":"lineCov","hits":"1","order":"1377",},
{"lineNum":"   95","line":"    }"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"    #[inline]"},
{"lineNum":"   98","line":"    pub fn remaining(&self) -> usize {"},
{"lineNum":"   99","line":"        self.entries.capacity() - self.len"},
{"lineNum":"  100","line":"    }"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"    #[inline]"},
{"lineNum":"  103","line":"    pub fn has_remaining(&self) -> bool {"},
{"lineNum":"  104","line":"        self.remaining() > 0"},
{"lineNum":"  105","line":"    }"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"    #[inline]"},
{"lineNum":"  108","line":"    pub fn contains(&self, idx: I) -> bool {"},
{"lineNum":"  109","line":"        match self.get(idx) {"},
{"lineNum":"  110","line":"            Some(_) => true,"},
{"lineNum":"  111","line":"            None => false"},
{"lineNum":"  112","line":"        }"},
{"lineNum":"  113","line":"    }"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"    pub fn get(&self, idx: I) -> Option<&T> {","class":"lineNoCov","hits":"0",},
{"lineNum":"  116","line":"        let idx = some!(self.local_index(idx));","class":"lineNoCov","hits":"0",},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"        match self.entries[idx] {","class":"lineNoCov","hits":"0",},
{"lineNum":"  119","line":"            Entry::Filled(ref val) => Some(val),","class":"lineNoCov","hits":"0",},
{"lineNum":"  120","line":"            Entry::Empty(_) => None,"},
{"lineNum":"  121","line":"        }"},
{"lineNum":"  122","line":"    }"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"    pub fn get_mut(&mut self, idx: I) -> Option<&mut T> {","class":"lineNoCov","hits":"0",},
{"lineNum":"  125","line":"        let idx = some!(self.local_index(idx));","class":"lineNoCov","hits":"0",},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"        return self.entries[idx].as_mut();","class":"lineNoCov","hits":"0",},
{"lineNum":"  128","line":"    }"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"    pub fn insert(&mut self, val: T) -> Result<I, T> {"},
{"lineNum":"  131","line":"        // check fail condition before val gets moved by insert_with,"},
{"lineNum":"  132","line":"        // so `Err(val)` can be returned"},
{"lineNum":"  133","line":"        if self.next >= self.entries.len() {"},
{"lineNum":"  134","line":"            return Err(val);"},
{"lineNum":"  135","line":"        }"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"        match self.insert_with(move |_| val ) {"},
{"lineNum":"  138","line":"            None => panic!(\"Slab::insert_with() should have not failed\"),"},
{"lineNum":"  139","line":"            Some(idx) => Ok(idx)"},
{"lineNum":"  140","line":"        }"},
{"lineNum":"  141","line":"    }"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"    /// Like `insert` but for objects that require newly allocated"},
{"lineNum":"  144","line":"    /// usize in their constructor."},
{"lineNum":"  145","line":"    pub fn insert_with<F>(&mut self, fun: F) -> Option<I> where F : FnOnce(I) -> T {"},
{"lineNum":"  146","line":"        let idx = self.next;"},
{"lineNum":"  147","line":"        if idx >= self.entries.len() {"},
{"lineNum":"  148","line":"            return None;"},
{"lineNum":"  149","line":"        }"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"        self.next = match self.entries[idx] {"},
{"lineNum":"  152","line":"            Entry::Empty(next) => next,"},
{"lineNum":"  153","line":"            Entry::Filled(_) => panic!(\"Tried to insert into filled index\")"},
{"lineNum":"  154","line":"        };"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"        self.entries[idx] = Entry::Filled(fun(I::from_usize(idx + self.offset)));"},
{"lineNum":"  157","line":"        self.len += 1;"},
{"lineNum":"  158","line":"        Some(I::from_usize(idx + self.offset))"},
{"lineNum":"  159","line":"    }"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"    /// Releases the given slot"},
{"lineNum":"  162","line":"    pub fn remove(&mut self, idx: I) -> Option<T> {","class":"lineNoCov","hits":"0",},
{"lineNum":"  163","line":"        let next = self.next;","class":"lineNoCov","hits":"0",},
{"lineNum":"  164","line":"        self.replace_(idx, Entry::Empty(next))","class":"lineNoCov","hits":"0",},
{"lineNum":"  165","line":"    }"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"    pub fn replace(&mut self, idx: I, t : T) -> Option<T> {"},
{"lineNum":"  168","line":"        self.replace_(idx, Entry::Filled(t))"},
{"lineNum":"  169","line":"    }"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"    /// Execute a function on the *value* in the slot and put the result of"},
{"lineNum":"  172","line":"    /// the function back into the slot. If function returns None,"},
{"lineNum":"  173","line":"    /// slot is left empty on exit."},
{"lineNum":"  174","line":"    ///"},
{"lineNum":"  175","line":"    /// Returns Err(()) if slot was empty"},
{"lineNum":"  176","line":"    ///"},
{"lineNum":"  177","line":"    /// This method is very useful for storing state machines inside Slab"},
{"lineNum":"  178","line":"    pub fn replace_with<F>(&mut self, idx: I, fun: F) -> Result<(), ()>"},
{"lineNum":"  179","line":"        where F: FnOnce(T) -> Option<T> {"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"            let raw_idx = idx.as_usize();"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"            // In current implementation we can just remove the element and insert"},
{"lineNum":"  184","line":"            // it again, but this guarantee is not documented"},
{"lineNum":"  185","line":"            if let Some(val) = self.remove(idx) {"},
{"lineNum":"  186","line":"                match fun(val) {"},
{"lineNum":"  187","line":"                    Some(newval) => {"},
{"lineNum":"  188","line":"                        let new_idx = self.insert(newval).ok().expect(\"We just deleted\");"},
{"lineNum":"  189","line":"                        // ... so we just assert that this guarantee is still ok"},
{"lineNum":"  190","line":"                        debug_assert!(raw_idx == new_idx.as_usize());"},
{"lineNum":"  191","line":"                        Ok(())"},
{"lineNum":"  192","line":"                    },"},
{"lineNum":"  193","line":"                    None => Ok(())"},
{"lineNum":"  194","line":"                }"},
{"lineNum":"  195","line":"            } else {"},
{"lineNum":"  196","line":"                Err(())"},
{"lineNum":"  197","line":"            }"},
{"lineNum":"  198","line":"        }"},
{"lineNum":"  199","line":""},
{"lineNum":"  200","line":"    /// Retain only the elements specified by the predicate."},
{"lineNum":"  201","line":"    ///"},
{"lineNum":"  202","line":"    /// In other words, remove all elements `e` such that `f(&e)` returns false."},
{"lineNum":"  203","line":"    /// This method operates in place and preserves the order of the retained"},
{"lineNum":"  204","line":"    /// elements."},
{"lineNum":"  205","line":"    pub fn retain<F>(&mut self, mut fun: F) where F: FnMut(&T) -> bool {"},
{"lineNum":"  206","line":"        for i in 0..self.len {"},
{"lineNum":"  207","line":"            let idx = I::from_usize(i + self.offset);"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"            let _ = self.replace_with(idx, |x| {"},
{"lineNum":"  210","line":"                if fun(&x) {"},
{"lineNum":"  211","line":"                    Some(x)"},
{"lineNum":"  212","line":"                } else {"},
{"lineNum":"  213","line":"                    None"},
{"lineNum":"  214","line":"                }"},
{"lineNum":"  215","line":"            });"},
{"lineNum":"  216","line":"        }"},
{"lineNum":"  217","line":"    }"},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"    pub fn iter(&self) -> SlabIter<T, I> {"},
{"lineNum":"  220","line":"        SlabIter {"},
{"lineNum":"  221","line":"            slab: self,"},
{"lineNum":"  222","line":"            cur_idx: 0,"},
{"lineNum":"  223","line":"            yielded: 0"},
{"lineNum":"  224","line":"        }"},
{"lineNum":"  225","line":"    }"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"    pub fn iter_mut(&mut self) -> SlabMutIter<T, I> {"},
{"lineNum":"  228","line":"        SlabMutIter { iter: self.iter() }"},
{"lineNum":"  229","line":"    }"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"    /// Empty the slab, by freeing all entries"},
{"lineNum":"  232","line":"    pub fn clear(&mut self) {"},
{"lineNum":"  233","line":"        for (i, e) in self.entries.iter_mut().enumerate() {"},
{"lineNum":"  234","line":"            *e = Entry::Empty(i + 1)"},
{"lineNum":"  235","line":"        }"},
{"lineNum":"  236","line":"        self.next = 0;"},
{"lineNum":"  237","line":"        self.len = 0;"},
{"lineNum":"  238","line":"    }"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"    /// Grow the slab, by adding `entries_num`"},
{"lineNum":"  241","line":"    pub fn grow(&mut self, entries_num : usize) {"},
{"lineNum":"  242","line":"        let prev_len = self.entries.len();"},
{"lineNum":"  243","line":"        let prev_len_next = prev_len + 1;"},
{"lineNum":"  244","line":"        self.entries.extend("},
{"lineNum":"  245","line":"            (prev_len_next..(prev_len_next + entries_num))"},
{"lineNum":"  246","line":"            .map(|n| Entry::Empty(n))"},
{"lineNum":"  247","line":"            );"},
{"lineNum":"  248","line":"        debug_assert_eq!(self.entries.len(), prev_len + entries_num);"},
{"lineNum":"  249","line":"    }"},
{"lineNum":"  250","line":""},
{"lineNum":"  251","line":"    fn local_index(&self, idx: I) -> Option<usize> {","class":"lineNoCov","hits":"0",},
{"lineNum":"  252","line":"        let idx = idx.as_usize();","class":"lineNoCov","hits":"0",},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"        if idx < self.offset {","class":"lineNoCov","hits":"0",},
{"lineNum":"  255","line":"            return None;"},
{"lineNum":"  256","line":"        }"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"        let idx = idx - self.offset;","class":"lineNoCov","hits":"0",},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"        if idx >= self.entries.capacity() {","class":"lineNoCov","hits":"0",},
{"lineNum":"  261","line":"            return None;"},
{"lineNum":"  262","line":"        }"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"        Some(idx)","class":"lineNoCov","hits":"0",},
{"lineNum":"  265","line":"    }"},
{"lineNum":"  266","line":""},
{"lineNum":"  267","line":"    #[inline]"},
{"lineNum":"  268","line":"    fn replace_(&mut self, idx: I, e: Entry<T>) -> Option<T> {","class":"lineNoCov","hits":"0",},
{"lineNum":"  269","line":"        let idx = some!(self.local_index(idx));","class":"lineNoCov","hits":"0",},
{"lineNum":"  270","line":""},
{"lineNum":"  271","line":"        if let Entry::Filled(val) = mem::replace(&mut self.entries[idx], e) {","class":"lineNoCov","hits":"0",},
{"lineNum":"  272","line":"            self.next = idx;","class":"lineNoCov","hits":"0",},
{"lineNum":"  273","line":"            self.len -= 1;","class":"lineNoCov","hits":"0",},
{"lineNum":"  274","line":"            return Some(val);","class":"lineNoCov","hits":"0",},
{"lineNum":"  275","line":"        }"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"        None","class":"lineNoCov","hits":"0",},
{"lineNum":"  278","line":"    }"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"}"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"impl<T, I: Index> ops::Index<I> for Slab<T, I> {"},
{"lineNum":"  283","line":"    type Output = T;"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"    fn index(&self, index: I) -> &T {","class":"lineNoCov","hits":"0",},
{"lineNum":"  286","line":"        self.get(index).expect(\"invalid index\")","class":"lineNoCov","hits":"0",},
{"lineNum":"  287","line":"    }"},
{"lineNum":"  288","line":"}"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"impl<T, I: Index> ops::IndexMut<I> for Slab<T, I> {"},
{"lineNum":"  291","line":"    fn index_mut(&mut self, index: I) -> &mut T {","class":"lineNoCov","hits":"0",},
{"lineNum":"  292","line":"        self.get_mut(index).expect(\"invalid index\")","class":"lineNoCov","hits":"0",},
{"lineNum":"  293","line":"    }"},
{"lineNum":"  294","line":"}"},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"impl<T, I : Index> fmt::Debug for Slab<T, I> {"},
{"lineNum":"  297","line":"    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  298","line":"        write!(fmt, \"Slab {{ len: {}, cap: {} }}\", self.len, self.entries.len())"},
{"lineNum":"  299","line":"    }"},
{"lineNum":"  300","line":"}"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"pub struct SlabIter<\'a, T: \'a, I : Index+\'a> {"},
{"lineNum":"  303","line":"    slab: &\'a Slab<T, I>,"},
{"lineNum":"  304","line":"    cur_idx: usize,"},
{"lineNum":"  305","line":"    yielded: usize"},
{"lineNum":"  306","line":"}"},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"impl<\'a, T, I : Index> Iterator for SlabIter<\'a, T, I> {"},
{"lineNum":"  309","line":"    type Item = &\'a T;"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"    fn next(&mut self) -> Option<&\'a T> {"},
{"lineNum":"  312","line":"        while self.yielded < self.slab.len {"},
{"lineNum":"  313","line":"            match self.slab.entries[self.cur_idx] {"},
{"lineNum":"  314","line":"                Entry::Filled(ref v) => {"},
{"lineNum":"  315","line":"                    self.cur_idx += 1;"},
{"lineNum":"  316","line":"                    self.yielded += 1;"},
{"lineNum":"  317","line":"                    return Some(v);"},
{"lineNum":"  318","line":"                }"},
{"lineNum":"  319","line":"                Entry::Empty(_) => {"},
{"lineNum":"  320","line":"                    self.cur_idx += 1;"},
{"lineNum":"  321","line":"                }"},
{"lineNum":"  322","line":"            }"},
{"lineNum":"  323","line":"        }"},
{"lineNum":"  324","line":""},
{"lineNum":"  325","line":"        None"},
{"lineNum":"  326","line":"    }"},
{"lineNum":"  327","line":"}"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"pub struct SlabMutIter<\'a, T: \'a, I : Index+\'a> {"},
{"lineNum":"  330","line":"    iter: SlabIter<\'a, T, I>,"},
{"lineNum":"  331","line":"}"},
{"lineNum":"  332","line":""},
{"lineNum":"  333","line":"impl<\'a, T, I : Index> Iterator for SlabMutIter<\'a, T, I> {"},
{"lineNum":"  334","line":"    type Item = &\'a mut T;"},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"    fn next(&mut self) -> Option<&\'a mut T> {"},
{"lineNum":"  337","line":"        unsafe { mem::transmute(self.iter.next()) }"},
{"lineNum":"  338","line":"    }"},
{"lineNum":"  339","line":"}"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"impl<\'a, T, I : Index> IntoIterator for &\'a Slab<T, I> {"},
{"lineNum":"  342","line":"    type Item = &\'a T;"},
{"lineNum":"  343","line":"    type IntoIter = SlabIter<\'a, T, I>;"},
{"lineNum":"  344","line":""},
{"lineNum":"  345","line":"    fn into_iter(self) -> SlabIter<\'a, T, I> {"},
{"lineNum":"  346","line":"        self.iter()"},
{"lineNum":"  347","line":"    }"},
{"lineNum":"  348","line":"}"},
{"lineNum":"  349","line":""},
{"lineNum":"  350","line":"impl<\'a, T, I : Index> IntoIterator for &\'a mut Slab<T, I> {"},
{"lineNum":"  351","line":"    type Item = &\'a mut T;"},
{"lineNum":"  352","line":"    type IntoIter = SlabMutIter<\'a, T, I>;"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"    fn into_iter(self) -> SlabMutIter<\'a, T, I> {"},
{"lineNum":"  355","line":"        self.iter_mut()"},
{"lineNum":"  356","line":"    }"},
{"lineNum":"  357","line":"}"},
{"lineNum":"  358","line":""},
{"lineNum":"  359","line":"#[cfg(test)]"},
{"lineNum":"  360","line":"mod tests {"},
{"lineNum":"  361","line":"    use super::Slab;"},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":"    #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]"},
{"lineNum":"  364","line":"    pub struct MyIndex(pub usize);"},
{"lineNum":"  365","line":""},
{"lineNum":"  366","line":"    impl super::Index for MyIndex {"},
{"lineNum":"  367","line":"        fn from_usize(i: usize) -> MyIndex {"},
{"lineNum":"  368","line":"            MyIndex(i)"},
{"lineNum":"  369","line":"        }"},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":"        fn as_usize(&self) -> usize {"},
{"lineNum":"  372","line":"            let MyIndex(inner) = *self;"},
{"lineNum":"  373","line":"            inner"},
{"lineNum":"  374","line":"        }"},
{"lineNum":"  375","line":"    }"},
{"lineNum":"  376","line":""},
{"lineNum":"  377","line":"    #[test]"},
{"lineNum":"  378","line":"    fn test_index_trait() {"},
{"lineNum":"  379","line":"        let mut slab = Slab::<usize, MyIndex>::new(1);"},
{"lineNum":"  380","line":"        let idx = slab.insert(10).ok().expect(\"Failed to insert\");"},
{"lineNum":"  381","line":"        assert_eq!(idx, MyIndex(0));"},
{"lineNum":"  382","line":"        assert_eq!(slab[idx], 10);"},
{"lineNum":"  383","line":"    }"},
{"lineNum":"  384","line":""},
{"lineNum":"  385","line":"    #[test]"},
{"lineNum":"  386","line":"    fn test_insertion() {"},
{"lineNum":"  387","line":"        let mut slab = Slab::<usize, usize>::new(1);"},
{"lineNum":"  388","line":"        assert_eq!(slab.is_empty(), true);"},
{"lineNum":"  389","line":"        assert_eq!(slab.has_remaining(), true);"},
{"lineNum":"  390","line":"        assert_eq!(slab.remaining(), 1);"},
{"lineNum":"  391","line":"        let idx = slab.insert(10).ok().expect(\"Failed to insert\");"},
{"lineNum":"  392","line":"        assert_eq!(slab[idx], 10);"},
{"lineNum":"  393","line":"        assert_eq!(slab.is_empty(), false);"},
{"lineNum":"  394","line":"        assert_eq!(slab.has_remaining(), false);"},
{"lineNum":"  395","line":"        assert_eq!(slab.remaining(), 0);"},
{"lineNum":"  396","line":"    }"},
{"lineNum":"  397","line":""},
{"lineNum":"  398","line":"    #[test]"},
{"lineNum":"  399","line":"    fn test_insert_with() {"},
{"lineNum":"  400","line":"        let mut slab = Slab::<usize, usize>::new_starting_at(1, 1);"},
{"lineNum":"  401","line":"        let tok = slab.insert_with(|_t| 5).unwrap();"},
{"lineNum":"  402","line":"        assert_eq!(slab.get(0), None);"},
{"lineNum":"  403","line":"        assert_eq!(slab.get_mut(0), None);"},
{"lineNum":"  404","line":"        assert_eq!(tok, 1);"},
{"lineNum":"  405","line":"    }"},
{"lineNum":"  406","line":""},
{"lineNum":"  407","line":"    #[test]"},
{"lineNum":"  408","line":"    fn test_repeated_insertion() {"},
{"lineNum":"  409","line":"        let mut slab = Slab::<usize, usize>::new(10);"},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"        for i in 0..10 {"},
{"lineNum":"  412","line":"            let idx = slab.insert(i + 10).ok().expect(\"Failed to insert\");"},
{"lineNum":"  413","line":"            assert_eq!(slab[idx], i + 10);"},
{"lineNum":"  414","line":"        }"},
{"lineNum":"  415","line":""},
{"lineNum":"  416","line":"        slab.insert(20).err().expect(\"Inserted when full\");"},
{"lineNum":"  417","line":"    }"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"    #[test]"},
{"lineNum":"  420","line":"    fn test_repeated_insertion_and_removal() {"},
{"lineNum":"  421","line":"        let mut slab = Slab::<usize, usize>::new(10);"},
{"lineNum":"  422","line":"        let mut indices = vec![];"},
{"lineNum":"  423","line":""},
{"lineNum":"  424","line":"        for i in 0..10 {"},
{"lineNum":"  425","line":"            let idx = slab.insert(i + 10).ok().expect(\"Failed to insert\");"},
{"lineNum":"  426","line":"            indices.push(idx);"},
{"lineNum":"  427","line":"            assert_eq!(slab[idx], i + 10);"},
{"lineNum":"  428","line":"        }"},
{"lineNum":"  429","line":""},
{"lineNum":"  430","line":"        for &i in indices.iter() {"},
{"lineNum":"  431","line":"            slab.remove(i);"},
{"lineNum":"  432","line":"        }"},
{"lineNum":"  433","line":""},
{"lineNum":"  434","line":"        slab.insert(20).ok().expect(\"Failed to insert in newly empty slab\");"},
{"lineNum":"  435","line":"    }"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"    #[test]"},
{"lineNum":"  438","line":"    fn test_insertion_when_full() {"},
{"lineNum":"  439","line":"        let mut slab = Slab::<usize, usize>::new(1);"},
{"lineNum":"  440","line":"        slab.insert(10).ok().expect(\"Failed to insert\");"},
{"lineNum":"  441","line":"        slab.insert(10).err().expect(\"Inserted into a full slab\");"},
{"lineNum":"  442","line":"    }"},
{"lineNum":"  443","line":""},
{"lineNum":"  444","line":"    #[test]"},
{"lineNum":"  445","line":"    fn test_removal_at_boundries() {"},
{"lineNum":"  446","line":"        let mut slab = Slab::<usize, usize>::new(1);"},
{"lineNum":"  447","line":"        assert_eq!(slab.remove(0), None);"},
{"lineNum":"  448","line":"        assert_eq!(slab.remove(1), None);"},
{"lineNum":"  449","line":"    }"},
{"lineNum":"  450","line":""},
{"lineNum":"  451","line":"    #[test]"},
{"lineNum":"  452","line":"    fn test_removal_is_successful() {"},
{"lineNum":"  453","line":"        let mut slab = Slab::<usize, usize>::new(1);"},
{"lineNum":"  454","line":"        let t1 = slab.insert(10).ok().expect(\"Failed to insert\");"},
{"lineNum":"  455","line":"        slab.remove(t1);"},
{"lineNum":"  456","line":"        let t2 = slab.insert(20).ok().expect(\"Failed to insert\");"},
{"lineNum":"  457","line":"        assert_eq!(slab[t2], 20);"},
{"lineNum":"  458","line":"    }"},
{"lineNum":"  459","line":""},
{"lineNum":"  460","line":"    #[test]"},
{"lineNum":"  461","line":"    fn test_mut_retrieval() {"},
{"lineNum":"  462","line":"        let mut slab = Slab::<_, usize>::new(1);"},
{"lineNum":"  463","line":"        let t1 = slab.insert(\"foo\".to_string()).ok().expect(\"Failed to insert\");"},
{"lineNum":"  464","line":""},
{"lineNum":"  465","line":"        slab[t1].push_str(\"bar\");"},
{"lineNum":"  466","line":""},
{"lineNum":"  467","line":"        assert_eq!(&slab[t1][..], \"foobar\");"},
{"lineNum":"  468","line":"    }"},
{"lineNum":"  469","line":""},
{"lineNum":"  470","line":"    #[test]"},
{"lineNum":"  471","line":"    #[should_panic]"},
{"lineNum":"  472","line":"    fn test_reusing_slots_1() {"},
{"lineNum":"  473","line":"        let mut slab = Slab::<usize, usize>::new(16);"},
{"lineNum":"  474","line":""},
{"lineNum":"  475","line":"        let t0 = slab.insert(123).unwrap();"},
{"lineNum":"  476","line":"        let t1 = slab.insert(456).unwrap();"},
{"lineNum":"  477","line":""},
{"lineNum":"  478","line":"        assert!(slab.count() == 2);"},
{"lineNum":"  479","line":"        assert!(slab.remaining() == 14);"},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"        slab.remove(t0);"},
{"lineNum":"  482","line":""},
{"lineNum":"  483","line":"        assert!(slab.count() == 1, \"actual={}\", slab.count());"},
{"lineNum":"  484","line":"        assert!(slab.remaining() == 15);"},
{"lineNum":"  485","line":""},
{"lineNum":"  486","line":"        slab.remove(t1);"},
{"lineNum":"  487","line":""},
{"lineNum":"  488","line":"        assert!(slab.count() == 0);"},
{"lineNum":"  489","line":"        assert!(slab.remaining() == 16);"},
{"lineNum":"  490","line":""},
{"lineNum":"  491","line":"        let _ = slab[t1];"},
{"lineNum":"  492","line":"    }"},
{"lineNum":"  493","line":""},
{"lineNum":"  494","line":"    #[test]"},
{"lineNum":"  495","line":"    fn test_reusing_slots_2() {"},
{"lineNum":"  496","line":"        let mut slab = Slab::<usize, usize>::new(16);"},
{"lineNum":"  497","line":""},
{"lineNum":"  498","line":"        let t0 = slab.insert(123).unwrap();"},
{"lineNum":"  499","line":""},
{"lineNum":"  500","line":"        assert!(slab[t0] == 123);"},
{"lineNum":"  501","line":"        assert!(slab.remove(t0) == Some(123));"},
{"lineNum":"  502","line":""},
{"lineNum":"  503","line":"        let t0 = slab.insert(456).unwrap();"},
{"lineNum":"  504","line":""},
{"lineNum":"  505","line":"        assert!(slab[t0] == 456);"},
{"lineNum":"  506","line":""},
{"lineNum":"  507","line":"        let t1 = slab.insert(789).unwrap();"},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"        assert!(slab[t0] == 456);"},
{"lineNum":"  510","line":"        assert!(slab[t1] == 789);"},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":"        assert!(slab.remove(t0).unwrap() == 456);"},
{"lineNum":"  513","line":"        assert!(slab.remove(t1).unwrap() == 789);"},
{"lineNum":"  514","line":""},
{"lineNum":"  515","line":"        assert!(slab.count() == 0);"},
{"lineNum":"  516","line":"    }"},
{"lineNum":"  517","line":""},
{"lineNum":"  518","line":"    #[test]"},
{"lineNum":"  519","line":"    #[should_panic]"},
{"lineNum":"  520","line":"    fn test_accessing_out_of_bounds() {"},
{"lineNum":"  521","line":"        let slab = Slab::<usize, usize>::new(16);"},
{"lineNum":"  522","line":"        slab[0];"},
{"lineNum":"  523","line":"    }"},
{"lineNum":"  524","line":""},
{"lineNum":"  525","line":"    #[test]"},
{"lineNum":"  526","line":"    fn test_contains() {"},
{"lineNum":"  527","line":"        let mut slab = Slab::new_starting_at(5 ,16);"},
{"lineNum":"  528","line":"        assert!(!slab.contains(0));"},
{"lineNum":"  529","line":""},
{"lineNum":"  530","line":"        let idx = slab.insert(111).unwrap();"},
{"lineNum":"  531","line":"        assert!(slab.contains(idx));"},
{"lineNum":"  532","line":"    }"},
{"lineNum":"  533","line":""},
{"lineNum":"  534","line":"    #[test]"},
{"lineNum":"  535","line":"    fn test_get() {"},
{"lineNum":"  536","line":"        let mut slab = Slab::<usize, usize>::new(16);"},
{"lineNum":"  537","line":"        let tok = slab.insert(5).unwrap();"},
{"lineNum":"  538","line":"        assert_eq!(slab.get(tok), Some(&5));"},
{"lineNum":"  539","line":"        assert_eq!(slab.get(1), None);"},
{"lineNum":"  540","line":"        assert_eq!(slab.get(23), None);"},
{"lineNum":"  541","line":"    }"},
{"lineNum":"  542","line":""},
{"lineNum":"  543","line":"    #[test]"},
{"lineNum":"  544","line":"    fn test_get_mut() {"},
{"lineNum":"  545","line":"        let mut slab = Slab::<u32, usize>::new(16);"},
{"lineNum":"  546","line":"        let tok = slab.insert(5u32).unwrap();"},
{"lineNum":"  547","line":"        {"},
{"lineNum":"  548","line":"            let mut_ref = slab.get_mut(tok).unwrap();"},
{"lineNum":"  549","line":"            assert_eq!(*mut_ref, 5);"},
{"lineNum":"  550","line":"            *mut_ref = 12;"},
{"lineNum":"  551","line":"        }"},
{"lineNum":"  552","line":"        assert_eq!(slab[tok], 12);"},
{"lineNum":"  553","line":"        assert_eq!(slab.get_mut(1), None);"},
{"lineNum":"  554","line":"        assert_eq!(slab.get_mut(23), None);"},
{"lineNum":"  555","line":"    }"},
{"lineNum":"  556","line":""},
{"lineNum":"  557","line":"    #[test]"},
{"lineNum":"  558","line":"    fn test_index_with_starting_at() {"},
{"lineNum":"  559","line":"        let mut slab = Slab::<usize, usize>::new_starting_at(1, 1);"},
{"lineNum":"  560","line":"        let tok = slab.insert(5).unwrap();"},
{"lineNum":"  561","line":"        assert_eq!(slab.get(0), None);"},
{"lineNum":"  562","line":"        assert_eq!(slab.get_mut(0), None);"},
{"lineNum":"  563","line":"        assert_eq!(tok, 1);"},
{"lineNum":"  564","line":"    }"},
{"lineNum":"  565","line":""},
{"lineNum":"  566","line":"    #[test]"},
{"lineNum":"  567","line":"    fn test_replace() {"},
{"lineNum":"  568","line":"        let mut slab = Slab::<usize, usize>::new(16);"},
{"lineNum":"  569","line":"        let tok = slab.insert(5).unwrap();"},
{"lineNum":"  570","line":"        assert!(slab.replace(tok, 6).is_some());"},
{"lineNum":"  571","line":"        assert!(slab.replace(tok+1, 555).is_none());"},
{"lineNum":"  572","line":"        assert_eq!(slab[tok], 6);"},
{"lineNum":"  573","line":"    }"},
{"lineNum":"  574","line":""},
{"lineNum":"  575","line":"    #[test]"},
{"lineNum":"  576","line":"    fn test_replace_with() {"},
{"lineNum":"  577","line":"        let mut slab = Slab::<u32, usize>::new(16);"},
{"lineNum":"  578","line":"        let tok = slab.insert(5u32).unwrap();"},
{"lineNum":"  579","line":"        assert!(slab.replace_with(tok, |x| Some(x+1)).is_ok());"},
{"lineNum":"  580","line":"        assert!(slab.replace_with(tok+1, |x| Some(x+1)).is_err());"},
{"lineNum":"  581","line":"        assert_eq!(slab[tok], 6);"},
{"lineNum":"  582","line":"    }"},
{"lineNum":"  583","line":""},
{"lineNum":"  584","line":"    #[test]"},
{"lineNum":"  585","line":"    fn test_retain() {"},
{"lineNum":"  586","line":"        let mut slab = Slab::<usize, usize>::new(2);"},
{"lineNum":"  587","line":"        let tok1 = slab.insert(0).unwrap();"},
{"lineNum":"  588","line":"        let tok2 = slab.insert(1).unwrap();"},
{"lineNum":"  589","line":"        slab.retain(|x| x % 2 == 0);"},
{"lineNum":"  590","line":"        assert_eq!(slab.count(), 1);"},
{"lineNum":"  591","line":"        assert_eq!(slab[tok1], 0);"},
{"lineNum":"  592","line":"        assert_eq!(slab.contains(tok2), false);"},
{"lineNum":"  593","line":"    }"},
{"lineNum":"  594","line":""},
{"lineNum":"  595","line":"    #[test]"},
{"lineNum":"  596","line":"    fn test_iter() {"},
{"lineNum":"  597","line":"        let mut slab = Slab::<u32, usize>::new_starting_at(0, 4);"},
{"lineNum":"  598","line":"        for i in 0..4 {"},
{"lineNum":"  599","line":"            slab.insert(i).unwrap();"},
{"lineNum":"  600","line":"        }"},
{"lineNum":"  601","line":""},
{"lineNum":"  602","line":"        let vals: Vec<u32> = slab.iter().map(|r| *r).collect();"},
{"lineNum":"  603","line":"        assert_eq!(vals, vec![0, 1, 2, 3]);"},
{"lineNum":"  604","line":""},
{"lineNum":"  605","line":"        slab.remove(1);"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"        let vals: Vec<u32> = slab.iter().map(|r| *r).collect();"},
{"lineNum":"  608","line":"        assert_eq!(vals, vec![0, 2, 3]);"},
{"lineNum":"  609","line":"    }"},
{"lineNum":"  610","line":""},
{"lineNum":"  611","line":"    #[test]"},
{"lineNum":"  612","line":"    fn test_iter_mut() {"},
{"lineNum":"  613","line":"        let mut slab = Slab::<u32, usize>::new_starting_at(0, 4);"},
{"lineNum":"  614","line":"        for i in 0..4 {"},
{"lineNum":"  615","line":"            slab.insert(i).unwrap();"},
{"lineNum":"  616","line":"        }"},
{"lineNum":"  617","line":"        for e in slab.iter_mut() {"},
{"lineNum":"  618","line":"            *e = *e + 1;"},
{"lineNum":"  619","line":"        }"},
{"lineNum":"  620","line":""},
{"lineNum":"  621","line":"        let vals: Vec<u32> = slab.iter().map(|r| *r).collect();"},
{"lineNum":"  622","line":"        assert_eq!(vals, vec![1, 2, 3, 4]);"},
{"lineNum":"  623","line":""},
{"lineNum":"  624","line":"        slab.remove(2);"},
{"lineNum":"  625","line":"        for e in slab.iter_mut() {"},
{"lineNum":"  626","line":"            *e = *e + 1;"},
{"lineNum":"  627","line":"        }"},
{"lineNum":"  628","line":""},
{"lineNum":"  629","line":"        let vals: Vec<u32> = slab.iter().map(|r| *r).collect();"},
{"lineNum":"  630","line":"        assert_eq!(vals, vec![2, 3, 5]);"},
{"lineNum":"  631","line":"    }"},
{"lineNum":"  632","line":""},
{"lineNum":"  633","line":"    #[test]"},
{"lineNum":"  634","line":"    fn test_iter_with_offset() {"},
{"lineNum":"  635","line":"        let mut slab = Slab::<u32, usize>::new_starting_at(2, 4);"},
{"lineNum":"  636","line":"        for i in 0..4 {"},
{"lineNum":"  637","line":"            slab.insert(i).unwrap();"},
{"lineNum":"  638","line":"        }"},
{"lineNum":"  639","line":""},
{"lineNum":"  640","line":"        let vals: Vec<u32> = slab.iter().map(|r| *r).collect();"},
{"lineNum":"  641","line":"        assert_eq!(vals, vec![0, 1, 2, 3]);"},
{"lineNum":"  642","line":"    }"},
{"lineNum":"  643","line":""},
{"lineNum":"  644","line":"    #[test]"},
{"lineNum":"  645","line":"    fn test_iter_mut_with_offset() {"},
{"lineNum":"  646","line":"        let mut slab = Slab::<u32, usize>::new_starting_at(2, 4);"},
{"lineNum":"  647","line":"        for i in 0..4 {"},
{"lineNum":"  648","line":"            slab.insert(i).unwrap();"},
{"lineNum":"  649","line":"        }"},
{"lineNum":"  650","line":""},
{"lineNum":"  651","line":"        let vals: Vec<u32> = slab.iter_mut().map(|r| *r).collect();"},
{"lineNum":"  652","line":"        assert_eq!(vals, vec![0, 1, 2, 3]);"},
{"lineNum":"  653","line":"    }"},
{"lineNum":"  654","line":""},
{"lineNum":"  655","line":"    #[test]"},
{"lineNum":"  656","line":"    fn test_grow() {"},
{"lineNum":"  657","line":"        let mut slab = Slab::<u32, usize>::new_starting_at(2, 4);"},
{"lineNum":"  658","line":"        for i in 0..4 {"},
{"lineNum":"  659","line":"            slab.insert(i).unwrap();"},
{"lineNum":"  660","line":"        }"},
{"lineNum":"  661","line":""},
{"lineNum":"  662","line":"        assert!(slab.insert(0).is_err());"},
{"lineNum":"  663","line":""},
{"lineNum":"  664","line":"        slab.grow(3);"},
{"lineNum":"  665","line":""},
{"lineNum":"  666","line":"        let vals: Vec<u32> = slab.iter().map(|r| *r).collect();"},
{"lineNum":"  667","line":"        assert_eq!(vals, vec![0, 1, 2, 3]);"},
{"lineNum":"  668","line":""},
{"lineNum":"  669","line":"        for i in 0..3 {"},
{"lineNum":"  670","line":"            slab.insert(i).unwrap();"},
{"lineNum":"  671","line":"        }"},
{"lineNum":"  672","line":"        assert!(slab.insert(0).is_err());"},
{"lineNum":"  673","line":""},
{"lineNum":"  674","line":"        let vals: Vec<u32> = slab.iter().map(|r| *r).collect();"},
{"lineNum":"  675","line":"        assert_eq!(vals, vec![0, 1, 2, 3, 0, 1, 2]);"},
{"lineNum":"  676","line":"    }"},
{"lineNum":"  677","line":""},
{"lineNum":"  678","line":"    #[test]"},
{"lineNum":"  679","line":"    fn test_clear() {"},
{"lineNum":"  680","line":"        let mut slab = Slab::<u32, usize>::new_starting_at(2, 4);"},
{"lineNum":"  681","line":"        for i in 0..4 {"},
{"lineNum":"  682","line":"            slab.insert(i).unwrap();"},
{"lineNum":"  683","line":"        }"},
{"lineNum":"  684","line":""},
{"lineNum":"  685","line":"        // clear full"},
{"lineNum":"  686","line":"        slab.clear();"},
{"lineNum":"  687","line":""},
{"lineNum":"  688","line":"        let vals: Vec<u32> = slab.iter().map(|r| *r).collect();"},
{"lineNum":"  689","line":"        assert_eq!(vals, vec![]);"},
{"lineNum":"  690","line":""},
{"lineNum":"  691","line":"        for i in 0..2 {"},
{"lineNum":"  692","line":"            slab.insert(i).unwrap();"},
{"lineNum":"  693","line":"        }"},
{"lineNum":"  694","line":""},
{"lineNum":"  695","line":"        let vals: Vec<u32> = slab.iter().map(|r| *r).collect();"},
{"lineNum":"  696","line":"        assert_eq!(vals, vec![0, 1]);"},
{"lineNum":"  697","line":""},
{"lineNum":"  698","line":""},
{"lineNum":"  699","line":"        // clear half-filled"},
{"lineNum":"  700","line":"        slab.clear();"},
{"lineNum":"  701","line":""},
{"lineNum":"  702","line":"        let vals: Vec<u32> = slab.iter().map(|r| *r).collect();"},
{"lineNum":"  703","line":"        assert_eq!(vals, vec![]);"},
{"lineNum":"  704","line":"    }"},
{"lineNum":"  705","line":""},
{"lineNum":"  706","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test_server-9ef2987148640087", "date" : "2016-02-17 13:22:50", "instrumented" : 46, "covered" : 14,};
var merged_data = [];
