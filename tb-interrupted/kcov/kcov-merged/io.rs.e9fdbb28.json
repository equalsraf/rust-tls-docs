var data = {lines:[
{"lineNum":"    1","line":"use {EventSet, Selector, PollOpt, Token};"},
{"lineNum":"    2","line":"use bytes::{Buf, MutBuf};"},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"// Re-export the io::Result / Error types for convenience"},
{"lineNum":"    5","line":"pub use std::io::{Read, Write, Result, Error, ErrorKind};"},
{"lineNum":"    6","line":""},
{"lineNum":"    7","line":"/// A value that may be registered with an `EventLoop`"},
{"lineNum":"    8","line":"pub trait Evented {"},
{"lineNum":"    9","line":"    #[doc(hidden)]"},
{"lineNum":"   10","line":"    fn register(&self, selector: &mut Selector, token: Token, interest: EventSet, opts: PollOpt) -> Result<()>;"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"    #[doc(hidden)]"},
{"lineNum":"   13","line":"    fn reregister(&self, selector: &mut Selector, token: Token, interest: EventSet, opts: PollOpt) -> Result<()>;"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"    #[doc(hidden)]"},
{"lineNum":"   16","line":"    fn deregister(&self, selector: &mut Selector) -> Result<()>;"},
{"lineNum":"   17","line":"}"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"pub trait TryRead {"},
{"lineNum":"   20","line":"    fn try_read_buf<B: MutBuf>(&mut self, buf: &mut B) -> Result<Option<usize>>"},
{"lineNum":"   21","line":"        where Self : Sized"},
{"lineNum":"   22","line":"    {"},
{"lineNum":"   23","line":"        // Reads the length of the slice supplied by buf.mut_bytes into the buffer"},
{"lineNum":"   24","line":"        // This is not guaranteed to consume an entire datagram or segment."},
{"lineNum":"   25","line":"        // If your protocol is msg based (instead of continuous stream) you should"},
{"lineNum":"   26","line":"        // ensure that your buffer is large enough to hold an entire segment (1532 bytes if not jumbo"},
{"lineNum":"   27","line":"        // frames)"},
{"lineNum":"   28","line":"        let res = self.try_read(unsafe { buf.mut_bytes() });"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"        if let Ok(Some(cnt)) = res {"},
{"lineNum":"   31","line":"            unsafe { buf.advance(cnt); }"},
{"lineNum":"   32","line":"        }"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"        res"},
{"lineNum":"   35","line":"    }"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"    fn try_read(&mut self, buf: &mut [u8]) -> Result<Option<usize>>;"},
{"lineNum":"   38","line":"}"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"pub trait TryWrite {"},
{"lineNum":"   41","line":"    fn try_write_buf<B: Buf>(&mut self, buf: &mut B) -> Result<Option<usize>>"},
{"lineNum":"   42","line":"        where Self : Sized"},
{"lineNum":"   43","line":"    {"},
{"lineNum":"   44","line":"        let res = self.try_write(buf.bytes());"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"        if let Ok(Some(cnt)) = res {"},
{"lineNum":"   47","line":"            buf.advance(cnt);"},
{"lineNum":"   48","line":"        }"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"        res"},
{"lineNum":"   51","line":"    }"},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"    fn try_write(&mut self, buf: &[u8]) -> Result<Option<usize>>;"},
{"lineNum":"   54","line":"}"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"impl<T: Read> TryRead for T {"},
{"lineNum":"   57","line":"    fn try_read(&mut self, dst: &mut [u8]) -> Result<Option<usize>> {","class":"lineNoCov","hits":"0",},
{"lineNum":"   58","line":"        self.read(dst).map_non_block()","class":"lineNoCov","hits":"0",},
{"lineNum":"   59","line":"    }","class":"lineNoCov","hits":"0",},
{"lineNum":"   60","line":"}"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"impl<T: Write> TryWrite for T {"},
{"lineNum":"   63","line":"    fn try_write(&mut self, src: &[u8]) -> Result<Option<usize>> {"},
{"lineNum":"   64","line":"        self.write(src).map_non_block()"},
{"lineNum":"   65","line":"    }"},
{"lineNum":"   66","line":"}"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"pub trait TryAccept {"},
{"lineNum":"   69","line":"    type Output;"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"    fn accept(&self) -> Result<Option<Self::Output>>;"},
{"lineNum":"   72","line":"}"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"/*"},
{"lineNum":"   75","line":" *"},
{"lineNum":"   76","line":" * ===== Helpers ====="},
{"lineNum":"   77","line":" *"},
{"lineNum":"   78","line":" */"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"/// A helper trait to provide the map_non_block function on Results."},
{"lineNum":"   81","line":"pub trait MapNonBlock<T> {"},
{"lineNum":"   82","line":"    /// Maps a `Result<T>` to a `Result<Option<T>>` by converting"},
{"lineNum":"   83","line":"    /// operation-would-block errors into `Ok(None)`."},
{"lineNum":"   84","line":"    fn map_non_block(self) -> Result<Option<T>>;"},
{"lineNum":"   85","line":"}"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"impl<T> MapNonBlock<T> for Result<T> {"},
{"lineNum":"   88","line":"    fn map_non_block(self) -> Result<Option<T>> {","class":"lineCov","hits":"1","order":"1162",},
{"lineNum":"   89","line":"        use std::io::ErrorKind::WouldBlock;"},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"        match self {","class":"lineCov","hits":"1","order":"1164",},
{"lineNum":"   92","line":"            Ok(value) => Ok(Some(value)),","class":"lineCov","hits":"1","order":"1165",},
{"lineNum":"   93","line":"            Err(err) => {"},
{"lineNum":"   94","line":"                if let WouldBlock = err.kind() {","class":"lineNoCov","hits":"0",},
{"lineNum":"   95","line":"                    Ok(None)"},
{"lineNum":"   96","line":"                } else {"},
{"lineNum":"   97","line":"                    Err(err)"},
{"lineNum":"   98","line":"                }"},
{"lineNum":"   99","line":"            }"},
{"lineNum":"  100","line":"        }"},
{"lineNum":"  101","line":"    }","class":"lineCov","hits":"1","order":"1163",},
{"lineNum":"  102","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test_server-9ef2987148640087", "date" : "2016-02-17 13:46:05", "instrumented" : 8, "covered" : 4,};
var merged_data = [];
